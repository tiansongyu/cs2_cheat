# CS2 内存结构基础：从零理解 Entity、Controller、Pawn 和 Handle

## 📌 前言

本文档面向对 CS2 内存结构感兴趣的初学者，将由浅入深地讲解：

1. **偏移量（Offset）是什么？为什么会失效？**
2. **Stride（步长）是什么？为什么会变化？**
3. **完整的内存结构图解**
4. **为什么这些值会随着游戏更新而改变？**

适合制作成视频教程，帮助小白理解 CS2 逆向工程的核心概念。

---

## 目录

- [第一部分：偏移量（Offset）基础](#第一部分偏移量offset基础)
  - [什么是偏移量？](#什么是偏移量)
  - [偏移量为什么会失效？](#偏移量为什么会失效)
  - [如何获取最新偏移量？](#如何获取最新偏移量)
- [第二部分：Stride（步长）的深层原理](#第二部分stride步长的深层原理)
  - [什么是 Stride？](#什么是-stride)
  - [2024-2025 年 Stride 变化事件](#2024-2025-年-stride-变化事件)
  - [Stride vs Offset：区别在哪？](#stride-vs-offset区别在哪)
- [第三部分：完整内存结构图解](#第三部分完整内存结构图解)
  - [从 client.dll 到玩家血量的完整路径](#从-clientdll-到玩家血量的完整路径)
  - [Entity、Controller、Pawn、Handle 关系图](#entitycontrollerpawnhandle-关系图)
- [第四部分：为什么这些值会变化？](#第四部分为什么这些值会变化)

---

## 第一部分：偏移量（Offset）基础

### 什么是偏移量？

**偏移量 = 相对位置**

想象一个 Excel 表格：

```
┌──────────────────────────────────────────────────────────────────────┐
│                     玩家对象（Pawn）在内存中的布局                    │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  假设 Pawn 基址 = 0x1000                                            │
│                                                                      │
│  ┌────────────┬────────────┬────────────────────────────────────┐   │
│  │   偏移量   │    数据    │              含义                  │   │
│  ├────────────┼────────────┼────────────────────────────────────┤   │
│  │   +0x000   │  VTable    │  虚函数表指针                      │   │
│  │   +0x008   │  ...       │  其他基类数据                      │   │
│  │   +0x34C   │  100       │  ← m_iHealth（血量）               │   │
│  │   +0x350   │  100       │  ← m_iMaxHealth（最大血量）        │   │
│  │   +0x3E3   │  2         │  ← m_iTeamNum（队伍：2=T, 3=CT）  │   │
│  │   +0x1224  │  100       │  ← m_ArmorValue（护甲）            │   │
│  │   +0x1324  │  x,y,z     │  ← m_vOldOrigin（3D坐标）         │   │
│  └────────────┴────────────┴────────────────────────────────────┘   │
│                                                                      │
│  【计算公式】                                                        │
│  血量地址 = Pawn基址 + 偏移量                                       │
│           = 0x1000 + 0x34C                                          │
│           = 0x134C                                                   │
│                                                                      │
│  护甲地址 = Pawn基址 + 偏移量                                       │
│           = 0x1000 + 0x1224                                         │
│           = 0x2224                                                   │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**简单来说：偏移量就是告诉你，从起点走多远能找到目标数据。**

### 实际例子：读取血量

```cpp
// 假设你已经找到了 Pawn 的基址
uintptr_t pawnAddress = 0x332CFD98000;

// 偏移量（来自 dumper）
uintptr_t m_iHealth_offset = 0x34C;

// 计算血量的实际地址
uintptr_t healthAddress = pawnAddress + m_iHealth_offset;
//                       = 0x332CFD98000 + 0x34C
//                       = 0x332CFD9834C

// 读取血量
int health = ReadMemory<int>(healthAddress);
// 结果: 100
```

**图示：**

```
              偏移量 0x34C
         ┌────────────────────┐
         │                    │
         ▼                    │
┌────────────────────────────────────────────────────┐
│ Pawn 对象                                          │
│ ┌─────────┬─────────┬─────────┬─────────┬────────┐ │
│ │ +0x000  │ +0x008  │  ....   │ +0x34C  │ +0x350 │ │
│ │ VTable  │  Data   │         │  100    │  100   │ │
│ │         │         │         │ (血量)  │(最大血)│ │
│ └─────────┴─────────┴─────────┴────▲────┴────────┘ │
│                                    │               │
│                                    └── 在这里找到血量
└────────────────────────────────────────────────────┘
  ▲
  │
  └── Pawn 基址: 0x332CFD98000
```

### 偏移量为什么会失效？

**每次游戏更新后，程序员可能修改了代码，导致数据在对象中的位置发生了变化。**

```
┌──────────────────────────────────────────────────────────────────────┐
│                     偏移量失效的原因示意图                           │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  【更新前】血量偏移 = 0x34C                                          │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  +0x000  │ +0x100 │ +0x200 │ +0x300 │ +0x34C │ +0x400      │    │
│  │  VTable  │ Data A │ Data B │ Data C │ Health │ Data D      │    │
│  │          │        │        │        │  100   │             │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                          ▲                           │
│                                          └── 血量在 0x34C            │
│                                                                      │
│  ════════════════════════════════════════════════════════════════   │
│                          ⬇ 游戏更新 ⬇                                │
│  ════════════════════════════════════════════════════════════════   │
│                                                                      │
│  【更新后】程序员添加了新功能，插入了一个新变量                      │
│                                                                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  +0x000  │ +0x100 │ +0x200 │ +0x300 │ +0x310 │ +0x35C │+0x410│  │
│  │  VTable  │ Data A │ Data B │ Data C │ ★新变量│ Health │Data D│  │
│  │          │        │        │        │   NEW  │  100   │      │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                  ▲              ▲                    │
│                                  │              │                    │
│                           新增16字节    血量偏移变成 0x35C           │
│                                                                      │
│  【后果】                                                            │
│  如果你还用 0x34C 读取血量：                                        │
│    → 读到的是 ★新变量 的值（比如 0x12345678）                       │
│    → 显示血量: 305419896 ← 完全错误！                               │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**关键理解**：

1. **偏移量不是 Valve 故意改的** - 是因为程序员修改了代码（添加/删除/修改变量），导致变量位置自然移动
2. **这是程序员不可控的** - 即使只是修改了其他不相关的代码，也可能因为编译器优化而改变偏移量
3. **更新频率高** - 每次 CS2 更新几乎都会有偏移量变化

### 如何获取最新偏移量？

**推荐工具**：[https://github.com/a2x/cs2-dumper](https://github.com/a2x/cs2-dumper)

这个仓库会在每次 CS2 更新后自动更新所有偏移量：

```
仓库结构:
├── output/
│   ├── offsets.hpp        ← 全局偏移量（dwEntityList, dwLocalPlayerPawn等）
│   ├── client_dll.hpp     ← client.dll 中的类和偏移量
│   ├── offsets.json       ← JSON 格式的偏移量
│   └── ...
```

**示例内容（offsets.hpp）**：

```cpp
// 2025-01-24 版本的偏移量
namespace offsets {
    constexpr std::ptrdiff_t dwEntityList = 0x19BBCC8;
    constexpr std::ptrdiff_t dwLocalPlayerPawn = 0x1825128;
    constexpr std::ptrdiff_t dwLocalPlayerController = 0x1A22E78;
    // ...
}
```

**使用方法**：

```
1. 访问 https://github.com/a2x/cs2-dumper
2. 查看最近的提交时间（确保是最新版本）
3. 下载 output/ 文件夹中的文件
4. 在你的代码中使用这些偏移量
```

---

## 第二部分：Stride（步长）的深层原理

### 什么是 Stride？

**Stride = 数组中每个元素之间的间距**

在 CS2 的 Entity List 中，所有实体指针按顺序存储在 Chunk（块）中：

```
┌──────────────────────────────────────────────────────────────────────┐
│                     Stride（步长）示意图                             │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Chunk 内存布局（每个 Chunk 存储 512 个实体指针）                    │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                                                                 │ │
│  │  地址           内容                 说明                       │ │
│  │  ─────────────────────────────────────────────────────────────  │ │
│  │  +0x000        Entity[0] 指针       ← 第 1 个实体               │ │
│  │  +0x070        Entity[1] 指针       ← 第 2 个实体               │ │
│  │  +0x0E0        Entity[2] 指针       ← 第 3 个实体               │ │
│  │  +0x150        Entity[3] 指针       ← 第 4 个实体               │ │
│  │  +0x1C0        Entity[4] 指针       ← 第 5 个实体               │ │
│  │  ...                                                            │ │
│  │                                                                 │ │
│  │  Stride = 0x70（112 字节）                                      │ │
│  │                                                                 │ │
│  │  计算公式：Entity[n] 地址 = Chunk基址 + Stride × n              │ │
│  │           Entity[3] 地址 = Chunk基址 + 0x70 × 3 = Chunk基址 + 0x150 │
│  │                                                                 │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│         ◄───── 0x70 ─────►◄───── 0x70 ─────►◄───── 0x70 ─────►      │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────┐  │
│  │   Entity[0]     │   Entity[1]     │   Entity[2]     │   ...   │  │
│  │   指针 + 其他   │   指针 + 其他   │   指针 + 其他   │         │  │
│  └─────────────────┴─────────────────┴─────────────────┴─────────┘  │
│                                                                      │
│  每个"槽位"包含：                                                    │
│   - 8 字节的实体指针                                                 │
│   - 104 字节的其他数据（引擎内部使用）                               │
│   - 共 112 字节 = 0x70                                               │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 2024-2025 年 Stride 变化事件

**这是一个真实发生的重大事件！**

```
┌──────────────────────────────────────────────────────────────────────┐
│              🚨 2025年初 Stride 变化事件 🚨                          │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  【时间线】                                                          │
│                                                                      │
│  2024年全年:                                                         │
│    Stride = 0x78 (120 字节)                                         │
│    大部分外挂/工具都使用这个值                                       │
│                                                                      │
│  2025年初某次更新:                                                   │
│    Stride = 0x70 (112 字节) ← 减少了 8 字节！                       │
│    ⚠️ 市面上大部分外挂瞬间失效！                                    │
│                                                                      │
│  ═══════════════════════════════════════════════════════════════    │
│                                                                      │
│  【变化对比图】                                                      │
│                                                                      │
│  ▼ 2024年版本（Stride = 0x78）                                      │
│                                                                      │
│       0x78         0x78         0x78         0x78                   │
│    ◄────────►  ◄────────►  ◄────────►  ◄────────►                   │
│  ┌──────────┬──────────┬──────────┬──────────┬──────────┐           │
│  │Entity[0] │Entity[1] │Entity[2] │Entity[3] │Entity[4] │           │
│  │  +0x000  │  +0x078  │  +0x0F0  │  +0x168  │  +0x1E0  │           │
│  └──────────┴──────────┴──────────┴──────────┴──────────┘           │
│                                                                      │
│  ▼ 2025年版本（Stride = 0x70）                                      │
│                                                                      │
│      0x70        0x70        0x70        0x70                       │
│    ◄───────►  ◄───────►  ◄───────►  ◄───────►                       │
│  ┌─────────┬─────────┬─────────┬─────────┬─────────┐                │
│  │Entity[0]│Entity[1]│Entity[2]│Entity[3]│Entity[4]│                │
│  │  +0x000 │  +0x070 │  +0x0E0 │  +0x150 │  +0x1C0 │                │
│  └─────────┴─────────┴─────────┴─────────┴─────────┘                │
│                                                                      │
│  【问题演示】使用旧 Stride 读取新版本游戏                            │
│                                                                      │
│  假设要读取 Entity[5]：                                              │
│                                                                      │
│  旧公式: 地址 = Chunk + 0x78 × 5 = Chunk + 0x258                    │
│  新公式: 地址 = Chunk + 0x70 × 5 = Chunk + 0x230                    │
│                                                                      │
│  差值: 0x258 - 0x230 = 0x28 = 40 字节                               │
│                                                                      │
│  结果: 读到完全错误的内存位置！                                      │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                     新版本的实际内存                        │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │  Entity[4]     Entity[5]     Entity[6]     Entity[7]        │    │
│  │   +0x1C0        +0x230        +0x2A0        +0x310          │    │
│  │      │             │             │             │            │    │
│  │      │             │      ┌──────┘             │            │    │
│  │      │             │      ▼                    │            │    │
│  │      │             │   +0x258 ← 旧公式读取到这里            │    │
│  │      │             │   (Entity[6]的中间位置)                │    │
│  │      │             │   读到的是垃圾数据！                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### Stride vs Offset：区别在哪？

```
┌──────────────────────────────────────────────────────────────────────┐
│                 Stride 和 Offset 的本质区别                          │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                          对比表                                │ │
│  ├───────────────┬────────────────────┬───────────────────────────┤ │
│  │     属性      │      Offset        │        Stride             │ │
│  ├───────────────┼────────────────────┼───────────────────────────┤ │
│  │   定义        │ 对象内部的属性位置 │ 数组中元素之间的间距      │ │
│  ├───────────────┼────────────────────┼───────────────────────────┤ │
│  │   层次        │ 浅层（属性级）     │ 深层（数据结构级）        │ │
│  ├───────────────┼────────────────────┼───────────────────────────┤ │
│  │   变化频率    │ 高（几乎每次更新） │ 低（引擎大更新才变）      │ │
│  ├───────────────┼────────────────────┼───────────────────────────┤ │
│  │   例子        │ m_iHealth = 0x34C  │ Entity Stride = 0x70      │ │
│  ├───────────────┼────────────────────┼───────────────────────────┤ │
│  │   影响范围    │ 单个属性读取失败   │ 所有实体遍历失败          │ │
│  ├───────────────┼────────────────────┼───────────────────────────┤ │
│  │   修复难度    │ 简单（查新偏移）   │ 困难（需要逆向分析）      │ │
│  └───────────────┴────────────────────┴───────────────────────────┘ │
│                                                                      │
│                                                                      │
│  【图解区别】                                                        │
│                                                                      │
│                    Stride（数组层面）                                │
│           ◄──────────────────────────────────►                       │
│                                                                      │
│  ┌─────────────────────┐    ┌─────────────────────┐                 │
│  │     Entity[0]       │    │     Entity[1]       │                 │
│  │  (一个 Pawn 对象)   │    │  (另一个 Pawn 对象) │                 │
│  │                     │    │                     │                 │
│  │  ┌───────────────┐  │    │  ┌───────────────┐  │                 │
│  │  │ +0x000 VTable │  │    │  │ +0x000 VTable │  │                 │
│  │  │ +0x34C Health │◄─┼────┼──┼ +0x34C Health │  │                 │
│  │  │ +0x3E3 Team   │  │    │  │ +0x3E3 Team   │  │                 │
│  │  │ +0x1224 Armor │  │    │  │ +0x1224 Armor │  │                 │
│  │  └───────────────┘  │    │  └───────────────┘  │                 │
│  │         ▲           │    │         ▲           │                 │
│  └─────────┼───────────┘    └─────────┼───────────┘                 │
│            │                          │                              │
│            │     Offset（对象内部）   │                              │
│            └──────────────────────────┘                              │
│                                                                      │
│                                                                      │
│  【关键理解】                                                        │
│                                                                      │
│  Offset 变化 = 只影响读取某个具体属性                                │
│    → 血量偏移变了？只有读血量失败，其他属性可能还对                  │
│                                                                      │
│  Stride 变化 = 影响整个实体遍历系统                                  │
│    → 所有实体都找不到了！ESP、雷达、自瞄全部失效                    │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

---

## 第三部分：完整内存结构图解

### 从 client.dll 到玩家血量的完整路径

这是 CS2 中最核心的内存访问路径，理解这个图就理解了整个实体系统：

```
┌────────────────────────────────────────────────────────────────────────────────┐
│            🎮 CS2 完整内存结构图：从 client.dll 到玩家血量的旅程              │
├────────────────────────────────────────────────────────────────────────────────┤
│                                                                                │
│                                                                                │
│  【第一层】模块基址                                                           │
│  ═════════════════════════════════════════════════════════════════════════    │
│                                                                                │
│      游戏进程 (cs2.exe)                                                       │
│           │                                                                    │
│           ├── client.dll  ──────────────────────────────────┐                 │
│           │   基址: 0x7FF6A2B40000                          │                 │
│           │                                                  ▼                 │
│           ├── engine2.dll                         ┌──────────────────┐        │
│           │                                       │ dwEntityList     │        │
│           ├── server.dll                          │ 偏移: 0x19BBCC8  │        │
│           │                                       └────────┬─────────┘        │
│           └── ...                                          │                  │
│                                                            │                  │
│                                                            │                  │
│  【第二层】全局指针                                         │                  │
│  ═════════════════════════════════════════════════════════ │ ═════════════    │
│                                                            │                  │
│                                                            ▼                  │
│         ┌──────────────────────────────────────────────────────────┐         │
│         │  client.dll + 0x19BBCC8                                  │         │
│         │  ┌──────────────────────────────────────────────────────┐│         │
│         │  │ Entity List 指针: 0x332089C0000                      ││         │
│         │  │                                                      ││         │
│         │  │ 这是一个指针，指向 Entity List 的实际位置           ││         │
│         │  └──────────────────────────────────────────────────────┘│         │
│         └──────────────────────────────────────────────────────────┘         │
│                                    │                                          │
│                                    │ 读取这个指针                             │
│                                    ▼                                          │
│                                                                                │
│  【第三层】Entity List 结构                                                   │
│  ═════════════════════════════════════════════════════════════════════════    │
│                                                                                │
│         Entity List (0x332089C0000)                                           │
│         ┌──────────────────────────────────────────────────────────┐         │
│         │  +0x00: [内部数据]                                       │         │
│         │  +0x08: [内部数据]                                       │         │
│         │  +0x10: Chunk[0] 指针 ───────────────────┐               │         │
│         │  +0x18: Chunk[1] 指针 ────────────────┐  │               │         │
│         │  +0x20: Chunk[2] 指针 ─────────────┐  │  │               │         │
│         │  +0x28: Chunk[3] 指针 ──────────┐  │  │  │               │         │
│         │  ...                            │  │  │  │               │         │
│         │  +0x208: Chunk[63] 指针         │  │  │  │               │         │
│         └─────────────────────────────────┼──┼──┼──┼───────────────┘         │
│                                           │  │  │  │                          │
│         64 个 Chunk，每个 Chunk 可容纳 512 个实体                             │
│         总容量: 64 × 512 = 32,768 个实体                                      │
│                                           │  │  │  │                          │
│                                           │  │  │  │                          │
│  【第四层】Chunk 结构                      │  │  │  │                          │
│  ═════════════════════════════════════════│══│══│══│══════════════════════    │
│                                           │  │  │  │                          │
│                                           │  │  │  │                          │
│     ┌─────────────────────────────────────┘  │  │  │                          │
│     │                                        │  │  │                          │
│     ▼                                        │  │  │                          │
│  Chunk[3] (0x33208CF3000)                    │  │  │                          │
│  ┌───────────────────────────────────────┐   │  │  │                          │
│  │  +0x000: Entity[1536] 指针            │   │  │  │                          │
│  │  +0x070: Entity[1537] 指针    ◄──Stride   │  │  │                          │
│  │  +0x0E0: Entity[1538] 指针            │   │  │  │                          │
│  │  ...                                  │   │  │  │                          │
│  │  +0x8F70: Entity[2047] 指针           │   │  │  │                          │
│  └───────────────────────────────────────┘   │  │  │                          │
│                                              │  │  │                          │
│     ┌────────────────────────────────────────┘  │  │                          │
│     │                                           │  │                          │
│     ▼                                           │  │                          │
│  Chunk[2] (0x33208CF2000)                       │  │                          │
│  ┌───────────────────────────────────────┐      │  │                          │
│  │  +0x000: Entity[1024] 指针            │      │  │                          │
│  │  +0x070: Entity[1025] 指针            │      │  │                          │
│  │  ...                                  │      │  │                          │
│  │  +0xC40: Entity[1052] 指针 ──────────────────┼──┼──► LocalPlayerPawn!      │
│  │  ...                                  │      │  │                          │
│  └───────────────────────────────────────┘      │  │                          │
│                                                 │  │                          │
│     ┌───────────────────────────────────────────┘  │                          │
│     │                                              │                          │
│     ▼                                              │                          │
│  Chunk[1] (0x33208CF1000)                          │                          │
│  ┌───────────────────────────────────────┐         │                          │
│  │  +0x000: Entity[512] 指针             │         │                          │
│  │  +0x070: Entity[513] 指针             │         │                          │
│  │  ...                                  │         │                          │
│  │  +0x8F70: Entity[1023] 指针           │         │                          │
│  └───────────────────────────────────────┘         │                          │
│                                                    │                          │
│     ┌──────────────────────────────────────────────┘                          │
│     │                                                                         │
│     ▼                                                                         │
│  Chunk[0] (0x33208CF0008)  ← 主要存放 Controller                              │
│  ┌───────────────────────────────────────┐                                    │
│  │  +0x000: Entity[0] 指针 = NULL        │                                    │
│  │  +0x070: Entity[1] 指针 ─────────────────────────────┐                     │
│  │  +0x0E0: Entity[2] 指针 ─────────────────────────┐   │                     │
│  │  +0x150: Entity[3] 指针 ─────────────────────┐   │   │                     │
│  │  ...                                         │   │   │                     │
│  │  +0x8F70: Entity[511] 指针                   │   │   │                     │
│  └──────────────────────────────────────────────┼───┼───┼─────────────────────┘
│                                                 │   │   │
│                                                 │   │   │
│  【第五层】Controller 对象                       │   │   │
│  ═══════════════════════════════════════════════│═══│═══│═════════════════════
│                                                 │   │   │
│                                                 │   │   │
│     ┌───────────────────────────────────────────┘   │   │
│     │                                               │   │
│     ▼                                               │   │
│  Controller[3] (0x332CFD53000)                      │   │
│  ┌───────────────────────────────────────┐          │   │
│  │  +0x000: VTable                       │          │   │
│  │  +0x62C: m_hPawn = 0x01D3061E ────────┼─┐        │   │
│  │  +0x640: m_iszPlayerName = "Bot3"     │ │        │   │
│  │  ...                                  │ │        │   │
│  └───────────────────────────────────────┘ │        │   │
│                                            │        │   │
│     ┌──────────────────────────────────────┘        │   │
│     │                                               │   │
│     │  Handle 解析:                                 │   │
│     │  0x01D3061E & 0x7FFF = 1054 (Index)           │   │
│     │  1054 >> 9 = 2 (Chunk)                        │   │
│     │  1054 & 0x1FF = 30 (在Chunk内的位置)           │   │
│     │                                               ▼   │
│     │                                                   │
│     │  ┌───────────────────────────────────────────────────────────────────┐
│     │  │                                                                   │
│     │  │  Controller[2] (0x332CFD52000)                                    │
│     │  │  ┌───────────────────────────────────────┐                        │
│     │  │  │  +0x000: VTable                       │                        │
│     │  │  │  +0x62C: m_hPawn = 0x01D3051D ────────┼─┐                      │
│     │  │  │  +0x640: m_iszPlayerName = "Bot2"     │ │                      │
│     │  │  │  ...                                  │ │                      │
│     │  │  └───────────────────────────────────────┘ │                      │
│     │  │                                            │                      │
│     │  └───────────────────────────────────────────┬┘                      │
│     │                                              │                       │
│     │                                              ▼                       │
│     │                                                                      │
│     │  Controller[1] (0x332CFD51000)  ← 本地玩家的 Controller              │
│     │  ┌───────────────────────────────────────┐                           │
│     │  │  +0x000: VTable                       │                           │
│     │  │  +0x62C: m_hPawn = 0x01D3041C ────────┼──┐                        │
│     │  │  +0x640: m_iszPlayerName = "Player"   │  │                        │
│     │  │  +0x6F0: m_iPing = 25                 │  │                        │
│     │  │  ...                                  │  │                        │
│     │  └───────────────────────────────────────┘  │                        │
│     │                                             │                        │
│     │                                             │                        │
│     │  【第六层】Handle 解析                       │                        │
│     │  ═══════════════════════════════════════════│═══════════════════════ │
│     │                                             │                        │
│     │              m_hPawn = 0x01D3041C           │                        │
│     │                        │                    │                        │
│     │                        ▼                    │                        │
│     │              ┌─────────────────────┐        │                        │
│     │              │   Handle 解析过程   │        │                        │
│     │              ├─────────────────────┤        │                        │
│     │              │                     │        │                        │
│     │              │ Step 1: 提取 Index  │        │                        │
│     │              │ 0x01D3041C & 0x7FFF │        │                        │
│     │              │ = 0x041C = 1052     │        │                        │
│     │              │                     │        │                        │
│     │              │ Step 2: 计算 Chunk  │        │                        │
│     │              │ 1052 >> 9 = 2       │        │                        │
│     │              │ (第 3 个 Chunk)     │        │                        │
│     │              │                     │        │                        │
│     │              │ Step 3: Chunk内位置 │        │                        │
│     │              │ 1052 & 0x1FF = 28   │        │                        │
│     │              │ (第 29 个槽位)      │        │                        │
│     │              │                     │        │                        │
│     │              └──────────┬──────────┘        │                        │
│     │                         │                   │                        │
│     │                         ▼                   │                        │
│     │                                             │                        │
│     │              在 Chunk[2] 的位置 28 找到 Pawn│                        │
│     │              Chunk[2] + 0x70 × 28           │                        │
│     │              = 0x33208CF2000 + 0xC40       │                        │
│     │              = 0x33208CF2C40                │                        │
│     │                         │                   │                        │
│     │                         │ 读取这个地址      │                        │
│     │                         ▼                   │                        │
│     │                                             │                        │
└─────┴─────────────────────────────────────────────┴────────────────────────┘

  【第七层】Pawn 对象（最终目标！）
  ═════════════════════════════════════════════════════════════════════════════

  LocalPlayerPawn (0x332CFD98000)
  ┌──────────────────────────────────────────────────────────────────────────┐
  │                                                                          │
  │  这就是玩家的实际游戏实体！包含所有游戏属性                              │
  │                                                                          │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │                                                                    │  │
  │  │  +0x000: VTable 指针                                               │  │
  │  │          ↓                                                         │  │
  │  │          指向虚函数表，用于识别对象类型                            │  │
  │  │                                                                    │  │
  │  │  +0x34C: m_iHealth = 100          ← 🩸 血量！                      │  │
  │  │                                                                    │  │
  │  │  +0x350: m_iMaxHealth = 100       ← 最大血量                       │  │
  │  │                                                                    │  │
  │  │  +0x3E3: m_iTeamNum = 2           ← 队伍 (2=T, 3=CT)              │  │
  │  │                                                                    │  │
  │  │  +0x3E4: m_lifeState = 0          ← 存活状态 (0=活着)             │  │
  │  │                                                                    │  │
  │  │  +0xCB0: m_vecViewOffset          ← 视角偏移 (x, y, z)            │  │
  │  │                                                                    │  │
  │  │  +0x1224: m_ArmorValue = 100      ← 🛡️ 护甲值                      │  │
  │  │                                                                    │  │
  │  │  +0x1324: m_vOldOrigin            ← 📍 3D 坐标                     │  │
  │  │           x = -1250.5                                              │  │
  │  │           y = 850.3                                                │  │
  │  │           z = -128.0                                               │  │
  │  │                                                                    │  │
  │  │  +0x1330: m_vecVelocity           ← 速度向量                       │  │
  │  │                                                                    │  │
  │  │  +0x23D0: m_hActiveWeapon         ← 当前武器 Handle                │  │
  │  │                                                                    │  │
  │  │  ...还有更多属性                                                   │  │
  │  │                                                                    │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  └──────────────────────────────────────────────────────────────────────────┘


  ═════════════════════════════════════════════════════════════════════════════
                              完整路径总结
  ═════════════════════════════════════════════════════════════════════════════

  读取血量的完整代码：

  1. entityList = Read(client.dll + 0x19BBCC8)         // 获取 Entity List
  2. chunk0 = Read(entityList + 0x10)                  // 获取 Chunk[0]
  3. controller = Read(chunk0 + 0x70 × playerIndex)    // 获取 Controller
  4. handle = Read(controller + 0x62C)                 // 获取 m_hPawn Handle
  5. index = handle & 0x7FFF                           // 提取索引
  6. chunkIdx = index >> 9                             // 计算 Chunk 索引
  7. offset = index & 0x1FF                            // 计算 Chunk 内偏移
  8. pawnChunk = Read(entityList + 0x10 + 8 × chunkIdx)// 获取 Pawn 所在 Chunk
  9. pawn = Read(pawnChunk + 0x70 × offset)            // 获取 Pawn 地址
  10. health = Read(pawn + 0x34C)                       // 终于读到血量！

  ═════════════════════════════════════════════════════════════════════════════
```

### Entity、Controller、Pawn、Handle 关系图

```
┌────────────────────────────────────────────────────────────────────────────────┐
│           🎯 Entity、Controller、Pawn、Handle 四者关系详解                    │
├────────────────────────────────────────────────────────────────────────────────┤
│                                                                                │
│                                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐  │
│  │                        为什么要分开？                                   │  │
│  ├─────────────────────────────────────────────────────────────────────────┤  │
│  │                                                                         │  │
│  │  场景1: 玩家正常游戏                                                    │  │
│  │                                                                         │  │
│  │    Controller ◄──────────────────────────► Pawn                        │  │
│  │    (逻辑信息)         m_hPawn              (物理信息)                   │  │
│  │    - 玩家名: "Player"                      - 血量: 100                  │  │
│  │    - 队伍: T                               - 坐标: (x,y,z)              │  │
│  │    - 金钱: $5000                           - 护甲: 100                  │  │
│  │                                            - 武器: AK-47                │  │
│  │                                                                         │  │
│  │  ───────────────────────────────────────────────────────────────────    │  │
│  │                                                                         │  │
│  │  场景2: 玩家死亡                                                        │  │
│  │                                                                         │  │
│  │    Controller ─────────── X ──────────── Pawn (已销毁)                  │  │
│  │    (逻辑信息)         m_hPawn = 0          ❌ 不存在了                  │  │
│  │    - 玩家名: "Player"                                                   │  │
│  │    - 队伍: T                                                            │  │
│  │    - 金钱: $5000                                                        │  │
│  │    ↑                                                                    │  │
│  │    │ Controller 还在！                                                  │  │
│  │    │ 玩家还在服务器，只是死了                                           │  │
│  │                                                                         │  │
│  │  ───────────────────────────────────────────────────────────────────    │  │
│  │                                                                         │  │
│  │  场景3: 玩家重生                                                        │  │
│  │                                                                         │  │
│  │    Controller ◄──────────────────────────► 新 Pawn                     │  │
│  │    (逻辑信息)         m_hPawn (新值)       (新的物理实体)               │  │
│  │    - 玩家名: "Player"                      - 血量: 100                  │  │
│  │    - 队伍: T                               - 新坐标: 出生点              │  │
│  │    - 金钱: $4000 (买了装备)                - 护甲: 0 (需要买)            │  │
│  │                                                                         │  │
│  └─────────────────────────────────────────────────────────────────────────┘  │
│                                                                                │
│                                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐  │
│  │                        Handle 是什么？                                   │  │
│  ├─────────────────────────────────────────────────────────────────────────┤  │
│  │                                                                         │  │
│  │  Handle = 一个 32 位整数，用于安全地引用实体                            │  │
│  │                                                                         │  │
│  │  ┌──────────────────────────────────────────────────────────────────┐   │  │
│  │  │                                                                  │   │  │
│  │  │     Handle: 0x01D3041C                                          │   │  │
│  │  │              ││││││││                                           │   │  │
│  │  │              ││└┴┴┴┴┴─── 低 15 位: Entity Index (1052)          │   │  │
│  │  │              │└────────── 第 16 位: 有效性标志                   │   │  │
│  │  │              └─────────── 高位: 序列号 (0x01D3)                  │   │  │
│  │  │                                                                  │   │  │
│  │  │  为什么用 Handle 而不用直接指针？                                │   │  │
│  │  │                                                                  │   │  │
│  │  │  ❌ 直接指针的问题:                                              │   │  │
│  │  │     - Pawn 被销毁后，指针变成悬空指针                            │   │  │
│  │  │     - 访问悬空指针 → 游戏崩溃！                                  │   │  │
│  │  │                                                                  │   │  │
│  │  │  ✅ Handle 的优势:                                               │   │  │
│  │  │     - 通过序列号可以检测实体是否已被销毁                         │   │  │
│  │  │     - 序列号不匹配 → 返回 NULL，安全！                           │   │  │
│  │  │                                                                  │   │  │
│  │  └──────────────────────────────────────────────────────────────────┘   │  │
│  │                                                                         │  │
│  │  【序列号工作原理】                                                     │  │
│  │                                                                         │  │
│  │  时刻 T1:                                                               │  │
│  │    Entity[100] = 玩家 A                                                 │  │
│  │    Handle = 0x0005_0064 (序列号=5, 索引=100)                            │  │
│  │                                                                         │  │
│  │  时刻 T2: 玩家 A 死亡，Entity[100] 被销毁                               │  │
│  │                                                                         │  │
│  │  时刻 T3:                                                               │  │
│  │    Entity[100] = 新玩家 B (重用了同一个槽位)                            │  │
│  │    Handle = 0x0006_0064 (序列号=6, 索引=100)                            │  │
│  │              ↑ 序列号增加了！                                           │  │
│  │                                                                         │  │
│  │  【安全检查】                                                           │  │
│  │    旧代码还持有 Handle 0x0005_0064                                      │  │
│  │    尝试访问 Entity[100]                                                 │  │
│  │    检查: 当前序列号 (6) ≠ Handle 中的序列号 (5)                         │  │
│  │    结果: 返回 NULL，避免错误访问！                                      │  │
│  │                                                                         │  │
│  └─────────────────────────────────────────────────────────────────────────┘  │
│                                                                                │
│                                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐  │
│  │                        四者关系总图                                     │  │
│  ├─────────────────────────────────────────────────────────────────────────┤  │
│  │                                                                         │  │
│  │                                                                         │  │
│  │                     ┌─────────────────────────────────┐                 │  │
│  │                     │         Entity List             │                 │  │
│  │                     │    (所有实体的索引表)           │                 │  │
│  │                     └───────────────┬─────────────────┘                 │  │
│  │                                     │                                   │  │
│  │              ┌──────────────────────┼──────────────────────┐            │  │
│  │              │                      │                      │            │  │
│  │              ▼                      ▼                      ▼            │  │
│  │       ┌────────────┐         ┌────────────┐         ┌────────────┐     │  │
│  │       │ Controller │         │ Controller │         │ Controller │     │  │
│  │       │    [1]     │         │    [2]     │         │    [3]     │     │  │
│  │       │            │         │            │         │            │     │  │
│  │       │ 玩家名     │         │ 玩家名     │         │ 玩家名     │     │  │
│  │       │ 队伍       │         │ 队伍       │         │ 队伍       │     │  │
│  │       │ 金钱       │         │ 金钱       │         │ 金钱       │     │  │
│  │       │            │         │            │         │            │     │  │
│  │       │ m_hPawn ───┼────┐    │ m_hPawn ───┼────┐    │ m_hPawn ───┼──┐  │  │
│  │       └────────────┘    │    └────────────┘    │    └────────────┘  │  │  │
│  │                         │                      │                    │  │  │
│  │                         │                      │                    │  │  │
│  │       ┌─────────────────┴──────────────────────┴────────────────────┘  │  │
│  │       │                 │                      │                       │  │
│  │       │    Handle       │      Handle          │     Handle            │  │
│  │       │   0x01D3041C    │     0x01D3051D       │    0x01D3061E         │  │
│  │       │       │         │         │            │        │              │  │
│  │       │       ▼         │         ▼            │        ▼              │  │
│  │       │  ┌─────────┐    │    ┌─────────┐       │   ┌─────────┐         │  │
│  │       │  │& 0x7FFF │    │    │& 0x7FFF │       │   │& 0x7FFF │         │  │
│  │       │  │ = 1052  │    │    │ = 1053  │       │   │ = 1054  │         │  │
│  │       │  └────┬────┘    │    └────┬────┘       │   └────┬────┘         │  │
│  │       │       │         │         │            │        │              │  │
│  │       │       ▼         │         ▼            │        ▼              │  │
│  │       │                 │                      │                       │  │
│  │       │     Entity List 索引                                          │  │
│  │       │                                                               │  │
│  │       └───────────────────────────────────────────────────────────────┘  │
│  │                         │                      │                    │     │
│  │                         ▼                      ▼                    ▼     │
│  │                  ┌────────────┐         ┌────────────┐       ┌────────────┐
│  │                  │   Pawn     │         │   Pawn     │       │   Pawn     │
│  │                  │  [1052]    │         │  [1053]    │       │  [1054]    │
│  │                  │            │         │            │       │            │
│  │                  │ 血量: 100  │         │ 血量: 100  │       │ 血量: 75   │
│  │                  │ 护甲: 100  │         │ 护甲: 50   │       │ 护甲: 0    │
│  │                  │ 坐标 xyz   │         │ 坐标 xyz   │       │ 坐标 xyz   │
│  │                  │ 武器       │         │ 武器       │       │ 武器       │
│  │                  └────────────┘         └────────────┘       └────────────┘
│  │                                                                         │  │
│  │                                                                         │  │
│  │  【索引分布规律】                                                       │  │
│  │                                                                         │  │
│  │  索引 1-64:    Controller (玩家控制器)                                  │  │
│  │  索引 65-511:  其他系统实体                                             │  │
│  │  索引 512+:    Pawn、武器、手雷、地图实体等                             │  │
│  │                                                                         │  │
│  │  Controller 和对应的 Pawn 索引不同！                                    │  │
│  │  例如: Controller[1] 的 Pawn 可能是 Entity[1052]                        │  │
│  │                                                                         │  │
│  └─────────────────────────────────────────────────────────────────────────┘  │
│                                                                                │
└────────────────────────────────────────────────────────────────────────────────┘
```

---

## 第四部分：为什么这些值会变化？

### 偏移量变化的真正原因

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    💡 偏移量变化的根本原因                               │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  【核心理解】                                                            │
│                                                                          │
│  偏移量变化 ≠ V社故意要破坏外挂                                         │
│  偏移量变化 = 代码修改的自然结果                                        │
│                                                                          │
│  ═══════════════════════════════════════════════════════════════════     │
│                                                                          │
│  【例子1: 添加新功能】                                                   │
│                                                                          │
│  V社程序员想给玩家添加一个新属性 "m_iNewStat"                           │
│                                                                          │
│  ▼ 修改前                                                                │
│  class C_CSPlayerPawn {                                                  │
│      int m_iHealth;      // 偏移 0x34C                                   │
│      int m_iMaxHealth;   // 偏移 0x350                                   │
│      int m_iTeamNum;     // 偏移 0x3E3                                   │
│  };                                                                      │
│                                                                          │
│  ▼ 修改后                                                                │
│  class C_CSPlayerPawn {                                                  │
│      int m_iHealth;      // 偏移 0x34C                                   │
│      int m_iNewStat;     // ★ 新增！偏移 0x350                          │
│      int m_iMaxHealth;   // 偏移变成 0x354 了！                          │
│      int m_iTeamNum;     // 偏移变成 0x3E7 了！                          │
│  };                                                                      │
│                                                                          │
│  → 后面所有属性的偏移都被推后了 4 字节！                                 │
│                                                                          │
│  ═══════════════════════════════════════════════════════════════════     │
│                                                                          │
│  【例子2: 删除旧功能】                                                   │
│                                                                          │
│  V社程序员决定删除一个不用的属性 "m_iOldUnused"                          │
│                                                                          │
│  ▼ 修改前                                                                │
│  class C_CSPlayerPawn {                                                  │
│      int m_iHealth;      // 偏移 0x34C                                   │
│      int m_iOldUnused;   // 偏移 0x350                                   │
│      int m_iMaxHealth;   // 偏移 0x354                                   │
│  };                                                                      │
│                                                                          │
│  ▼ 修改后                                                                │
│  class C_CSPlayerPawn {                                                  │
│      int m_iHealth;      // 偏移 0x34C                                   │
│      int m_iMaxHealth;   // 偏移变成 0x350 了！                          │
│  };                                                                      │
│                                                                          │
│  → 后面所有属性的偏移都被前移了 4 字节！                                 │
│                                                                          │
│  ═══════════════════════════════════════════════════════════════════     │
│                                                                          │
│  【例子3: 编译器优化】                                                   │
│                                                                          │
│  即使源代码没变，不同版本的编译器也可能：                                │
│  - 重新排列变量顺序（优化内存对齐）                                      │
│  - 添加/删除填充字节（padding）                                          │
│  - 内联展开某些结构                                                      │
│                                                                          │
│  结果：偏移量莫名其妙就变了！                                            │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### Stride 变化的原因

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    💡 Stride 变化的根本原因                              │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Stride 变化比偏移量变化更罕见，但影响更大                               │
│                                                                          │
│  ═══════════════════════════════════════════════════════════════════     │
│                                                                          │
│  【Stride 变化的原因】                                                   │
│                                                                          │
│  1. 引擎核心数据结构重构                                                 │
│     - Entity 槽位结构本身被修改                                          │
│     - 这是引擎层面的变化，非常罕见                                       │
│                                                                          │
│  2. 内存管理策略变化                                                     │
│     - 每个槽位分配的大小改变                                             │
│     - 可能是为了优化内存使用                                             │
│                                                                          │
│  3. 缓存行优化                                                           │
│     - 现代 CPU 的缓存行通常是 64 字节                                    │
│     - 调整 Stride 可能是为了更好的缓存对齐                               │
│                                                                          │
│  ═══════════════════════════════════════════════════════════════════     │
│                                                                          │
│  【2024-2025 Stride 变化分析】                                           │
│                                                                          │
│  0x78 (120字节) → 0x70 (112字节)                                        │
│                                                                          │
│  减少了 8 字节，可能的原因：                                             │
│  - 删除了槽位中的某个 8 字节字段                                         │
│  - 优化了内存对齐方式                                                    │
│  - 重构了内部指针结构                                                    │
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │                                                                │     │
│  │  旧版本槽位结构 (0x78 = 120 字节)                             │     │
│  │  ┌────────────────────────────────────────────────────────────┐│     │
│  │  │ Entity指针(8) │ 其他数据(104) │ 额外字段(8) │             ││     │
│  │  │               │               │    ↑        │             ││     │
│  │  │               │               │  被删除了   │             ││     │
│  │  └────────────────────────────────────────────────────────────┘│     │
│  │                                                                │     │
│  │  新版本槽位结构 (0x70 = 112 字节)                             │     │
│  │  ┌────────────────────────────────────────────────────────┐   │     │
│  │  │ Entity指针(8) │ 其他数据(104) │                        │   │     │
│  │  └────────────────────────────────────────────────────────┘   │     │
│  │                                                                │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### 总结：什么时候需要更新什么？

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    📋 更新检查清单                                       │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                                                                    │ │
│  │  【每次 CS2 更新后】                                               │ │
│  │                                                                    │ │
│  │  ✅ 检查偏移量                                                     │ │
│  │     - 访问 https://github.com/a2x/cs2-dumper                      │ │
│  │     - 下载最新的 offsets.hpp 和 client_dll.hpp                    │ │
│  │     - 更新你代码中的偏移量                                         │ │
│  │                                                                    │ │
│  │  ✅ 测试功能                                                       │ │
│  │     - 读取血量、坐标等基本数据                                     │ │
│  │     - 如果数据正确 → 只是偏移量变了                               │ │
│  │     - 如果数据完全错误 → 可能 Stride 也变了                       │ │
│  │                                                                    │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                                                                    │ │
│  │  【如果怀疑 Stride 变化】                                          │ │
│  │                                                                    │ │
│  │  🔍 手动验证方法：                                                 │ │
│  │                                                                    │ │
│  │  1. 在 Cheat Engine 中找到 Entity List                            │ │
│  │  2. 找到一个 Chunk 的起始地址                                      │ │
│  │  3. 查看连续两个非空实体指针的地址差                               │ │
│  │  4. 地址差 = 新的 Stride                                          │ │
│  │                                                                    │ │
│  │  📝 代码验证方法：                                                 │ │
│  │                                                                    │ │
│  │  for (stride = 0x60; stride <= 0x90; stride += 0x8) {             │ │
│  │      entity = Read(chunk + stride * knownIndex);                  │ │
│  │      if (entity == knownPawnAddress) {                            │ │
│  │          printf("Stride = 0x%X\n", stride);                       │ │
│  │          break;                                                    │ │
│  │      }                                                             │ │
│  │  }                                                                 │ │
│  │                                                                    │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                                                                    │ │
│  │  【关键常量记录】                                                  │ │
│  │                                                                    │ │
│  │  当前版本 (2025年1月):                                             │ │
│  │                                                                    │ │
│  │  - Stride = 0x70 (112 字节)                                       │ │
│  │  - Base Offset = 0x10 (Chunk 数组起始)                            │ │
│  │  - Chunk Size = 512 (每个 Chunk 的实体数)                         │ │
│  │  - Handle Mask = 0x7FFF (提取索引)                                │ │
│  │  - Chunk Shift = 9 (计算 Chunk 索引)                              │ │
│  │  - Chunk Mask = 0x1FF (计算 Chunk 内偏移)                         │ │
│  │                                                                    │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

---

## 附录：完整代码示例

### 获取玩家 Pawn 的完整实现

```cpp
#include <cstdint>
#include <iostream>

// 假设你有一个 Memory 类用于读取进程内存
class Memory {
public:
    template<typename T>
    T read(uintptr_t address);
};

Memory mem;
uintptr_t clientBase;  // client.dll 基址

// 偏移量（需要定期更新！）
namespace offsets {
    constexpr uintptr_t dwEntityList = 0x19BBCC8;
    constexpr uintptr_t m_hPawn = 0x62C;
    constexpr uintptr_t m_iHealth = 0x34C;
    constexpr uintptr_t m_iTeamNum = 0x3E3;
    constexpr uintptr_t m_vOldOrigin = 0x1324;
}

// 常量（很少变化，但也需要注意）
namespace constants {
    constexpr uintptr_t BASE_OFFSET = 0x10;     // Chunk 数组偏移
    constexpr uintptr_t STRIDE = 0x70;          // 实体步长
    constexpr uint32_t CHUNK_SIZE = 512;        // 每个 Chunk 的大小
    constexpr uint32_t HANDLE_MASK = 0x7FFF;    // 索引掩码
}

// 从索引获取实体
uintptr_t GetEntityByIndex(uintptr_t entityList, uint32_t index) {
    uint32_t chunkIndex = index >> 9;           // index / 512
    uint32_t indexInChunk = index & 0x1FF;      // index % 512

    // 读取 Chunk 指针
    uintptr_t chunkPtr = mem.read<uintptr_t>(
        entityList + constants::BASE_OFFSET + 0x8 * chunkIndex
    );

    if (!chunkPtr) return 0;

    // 读取实体指针
    return mem.read<uintptr_t>(chunkPtr + constants::STRIDE * indexInChunk);
}

// 从 Handle 获取实体
uintptr_t GetEntityFromHandle(uintptr_t entityList, uint32_t handle) {
    if (!handle || handle == 0xFFFFFFFF) return 0;

    uint32_t index = handle & constants::HANDLE_MASK;
    return GetEntityByIndex(entityList, index);
}

// 获取玩家 Pawn
uintptr_t GetPlayerPawn(uint32_t playerIndex) {
    // 1. 获取 Entity List
    uintptr_t entityList = mem.read<uintptr_t>(clientBase + offsets::dwEntityList);
    if (!entityList) return 0;

    // 2. 获取 Controller
    uintptr_t controller = GetEntityByIndex(entityList, playerIndex);
    if (!controller) return 0;

    // 3. 读取 m_hPawn Handle
    uint32_t pawnHandle = mem.read<uint32_t>(controller + offsets::m_hPawn);
    if (!pawnHandle) return 0;

    // 4. 从 Handle 获取 Pawn
    return GetEntityFromHandle(entityList, pawnHandle);
}

// 使用示例
void PrintPlayerInfo(uint32_t playerIndex) {
    uintptr_t pawn = GetPlayerPawn(playerIndex);
    if (!pawn) {
        std::cout << "Player " << playerIndex << " not found or dead\n";
        return;
    }

    int health = mem.read<int>(pawn + offsets::m_iHealth);
    int team = mem.read<int>(pawn + offsets::m_iTeamNum);

    struct Vec3 { float x, y, z; };
    Vec3 pos = mem.read<Vec3>(pawn + offsets::m_vOldOrigin);

    std::cout << "Player " << playerIndex << ":\n";
    std::cout << "  Health: " << health << "\n";
    std::cout << "  Team: " << (team == 2 ? "T" : "CT") << "\n";
    std::cout << "  Position: (" << pos.x << ", " << pos.y << ", " << pos.z << ")\n";
}
```

---

## 免责声明

本文档仅供教育和学习目的使用。

- 本文档内容仅用于学习逆向工程和内存分析技术
- 不鼓励在在线游戏中使用作弊工具
- 使用本文档中的技术可能违反游戏服务条款
- 作者不对任何滥用行为负责

---

**文档版本**: 1.0
**最后更新**: 2025-01-24
**作者**: CS2 逆向工程教程

如有问题或建议，欢迎提交 Issue 或 Pull Request！


