# CS2 视图矩阵数学原理详解

## 目录
1. [核心发现：CS2 使用列向量体系](#1-核心发现cs2-使用列向量体系)
2. [两种矩阵乘法体系对比](#2-两种矩阵乘法体系对比)
3. [数学原理：为什么 P×V×W ≠ Wᵀ×(V×P)](#3-数学原理为什么-pvw--wᵀvp)
4. [CS2 的 dwViewMatrix 内存布局](#4-cs2-的-dwviewmatrix-内存布局)
5. [实际应用：WorldToScreen](#5-实际应用worldtoscreen)
6. [总结](#6-总结)

---

## 1. 核心发现：CS2 使用列向量体系

### 1.1 通过 Cheat Engine 逆向发现

通过 Cheat Engine 对 CS2 内存进行分析，发现了一个关键事实：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   CS2 使用的是：  P × V × WorldPosition  （列向量体系）                      │
│                                                                             │
│   而不是：        WorldPosition × V × P  （行向量体系）                      │
│                                                                             │
│   内存中的 dwViewMatrix = P × V  （投影矩阵 × 视图矩阵）                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```


$$V = \begin{bmatrix} 
R_x & R_y & R_z & 0 \\ 
U_x & U_y & U_z & 0 \\ 
F_x & F_y & F_z & 0 \\ 
T_x & T_y & T_z & 1 
\end{bmatrix}, \quad
P = \begin{bmatrix} 
f/a & 0 & 0 & 0 \\ 
0 & f & 0 & 0 \\ 
0 & 0 & A & 1 \\ 
0 & 0 & B & 0 
\end{bmatrix}$$

按照directx 的风格，应该是如下的矩阵：

$$M = V
\times
P$$

$$M = \begin{bmatrix} 
R_x \cdot \frac{f}{a} & R_y \cdot f & R_z \cdot A & R_z \\ 
U_x \cdot \frac{f}{a} & U_y \cdot f & U_z \cdot A & U_z \\ 
F_x \cdot \frac{f}{a} & F_y \cdot f & F_z \cdot A & F_z \\ 
T_x \cdot \frac{f}{a} & T_y \cdot f & T_z \cdot A + B & T_z 
\end{bmatrix}$$

但实际内存中是这样的风格：
 
$$M = P
\times
V$$

$$M = \begin{bmatrix} 
\mathbf{\frac{f}{a} R_x} & \mathbf{\frac{f}{a} R_y} & \mathbf{\frac{f}{a} R_z} & \mathbf{\frac{f}{a} T_x} \\ 
\mathbf{f U_x} & \mathbf{f U_y} & \mathbf{f U_z} & \mathbf{f T_y} \\ 
A F_x & A F_y & A F_z & A T_z + B \\ 
F_x & F_y & F_z & T_z 
\end{bmatrix}$$

### 1.2 这意味着什么？

从上面的矩阵乘法结果可以看出：

- **DirectX 风格 (V × P)**：矩阵第一列包含 `Rx·f/a, Ux·f/a, Fx·f/a, Tx·f/a`
- **CS2 实际内存 (P × V)**：矩阵第一行包含 `f/a·Rx, f/a·Ry, f/a·Rz, f/a·Tx`

这证明了 CS2 使用的是 **P × V** 的乘法顺序！

```
CS2 的列向量体系：
─────────────────────────────────────────────────────────────

    ClipCoords = dwViewMatrix × WorldPosition
               = (P × V) × W

    矩阵在左，向量在右，从右往左读变换顺序：
    先 V（视图变换），再 P（投影变换）

    内存中 dwViewMatrix = P × V


如果是 DirectX 风格（行向量体系）：
─────────────────────────────────────────────────────────────

    ClipCoords = WorldPosition × dwViewMatrix
               = W × (V × P)

    向量在左，矩阵在右，从左往右读变换顺序：
    先 V（视图变换），再 P（投影变换）

    内存中 dwViewMatrix = V × P  ← 但 CS2 不是这样！
```

---

## 2. 两种矩阵乘法体系对比

### 2.1 列向量 vs 行向量

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        列向量体系 (Column-Major)                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   向量表示为 4×1 的"竖着的"列向量：                                          │
│                                                                             │
│       ┌   ┐                                                                 │
│       │ x │                                                                 │
│   W = │ y │    (4×1)                                                        │
│       │ z │                                                                 │
│       │ 1 │                                                                 │
│       └   ┘                                                                 │
│                                                                             │
│   矩阵乘法：  Result = Matrix × Vector                                       │
│              (4×1)  = (4×4) × (4×1)                                         │
│                                                                             │
│   变换顺序：从右往左读                                                       │
│   P × V × W  意味着：先应用 V，再应用 P                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                        行向量体系 (Row-Major)                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   向量表示为 1×4 的"躺着的"行向量：                                          │
│                                                                             │
│   Wᵀ = [ x  y  z  1 ]    (1×4)                                              │
│                                                                             │
│   矩阵乘法：  Result = Vector × Matrix                                       │
│              (1×4)  = (1×4) × (4×4)                                         │
│                                                                             │
│   变换顺序：从左往右读                                                       │
│   Wᵀ × V × P  意味着：先应用 V，再应用 P                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 两种体系的等价关系

```
关键数学关系：

    如果在列向量体系中：  Result = M × W

    那么在行向量体系中：  Resultᵀ = Wᵀ × Mᵀ

    其中 Mᵀ 是 M 的转置矩阵


这意味着：
─────────────────────────────────────────────────────────────

    列向量：  Clip = (P × V) × W

    等价于

    行向量：  Clipᵀ = Wᵀ × (P × V)ᵀ = Wᵀ × Vᵀ × Pᵀ

    注意：(P × V)ᵀ = Vᵀ × Pᵀ  （转置会反转乘法顺序！）
```

---

## 3. 数学原理：为什么 P×V×W ≠ Wᵀ×(V×P)

### 3.1 维度与结果类型的冲突

这是一个硬核的数学问题。让我们严格分析：

```
P × V × W （列向量体系）：
─────────────────────────────────────────────────────────────

    P: 4×4 矩阵（投影矩阵）
    V: 4×4 矩阵（视图矩阵）
    W: 4×1 列向量（世界坐标）

    计算过程：
    (4×4) × (4×4) × (4×1)
         ↓
       (4×4) × (4×1)
              ↓
            (4×1)  ← 结果是 4×1 的列向量


Wᵀ × (V × P) （行向量体系，但顺序错误）：
─────────────────────────────────────────────────────────────

    Wᵀ: 1×4 行向量（世界坐标的转置）
    V:  4×4 矩阵（视图矩阵）
    P:  4×4 矩阵（投影矩阵）

    计算过程：
    (1×4) × [(4×4) × (4×4)]
    (1×4) × (4×4)
           ↓
         (1×4)  ← 结果是 1×4 的行向量
```

### 3.2 结论一：形状不同

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   P × V × W  的结果是 4×1 的列向量（"站着的"）                               │
│                                                                             │
│   Wᵀ × (V × P) 的结果是 1×4 的行向量（"躺着的"）                             │
│                                                                             │
│   即便数值对应，它们在数学对象上是不等的！                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 结论二：变换顺序不同

```
更严重的问题：变换顺序被反转了！

P × V × W：
─────────────────────────────────────────────────────────────
    从右往左读：先 V（视图变换），再 P（投影变换）
    这是正确的顺序！


Wᵀ × (V × P)：
─────────────────────────────────────────────────────────────
    从左往右读：先 V（视图变换），再 P（投影变换）
    看起来顺序一样？

    但是！(V × P) 作为组合矩阵，在行向量体系中应该是 (P × V)ᵀ = Vᵀ × Pᵀ
    而不是 V × P！

    所以 Wᵀ × (V × P) 实际上是：先 P，再 V
    这是错误的顺序！
```

### 3.4 正确的等价关系

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           正确的数学等价关系                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   列向量体系：                                                               │
│       Clip = (P × V) × W                                                    │
│                                                                             │
│   等价的行向量体系：                                                         │
│       Clipᵀ = Wᵀ × (P × V)ᵀ                                                 │
│             = Wᵀ × Vᵀ × Pᵀ                                                  │
│                                                                             │
│   注意：需要对每个矩阵取转置，并且反转乘法顺序！                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

证明：
─────────────────────────────────────────────────────────────

    设 Clip = (P × V) × W

    对两边取转置：
    Clipᵀ = [(P × V) × W]ᵀ

    利用转置性质 (A × B)ᵀ = Bᵀ × Aᵀ：
    Clipᵀ = Wᵀ × (P × V)ᵀ
          = Wᵀ × Vᵀ × Pᵀ

    这才是正确的等价形式！
```

### 3.5 为什么 Wᵀ × (V × P) 是错的

```
错误分析：
─────────────────────────────────────────────────────────────

    Wᵀ × (V × P)  ≠  [P × V × W]ᵀ

    因为：
    [P × V × W]ᵀ = Wᵀ × (P × V)ᵀ = Wᵀ × Vᵀ × Pᵀ

    而：
    Wᵀ × (V × P) = Wᵀ × V × P

    除非 V 和 P 都是对称矩阵（Mᵀ = M），否则：
    Vᵀ × Pᵀ ≠ V × P

    投影矩阵和视图矩阵通常都不是对称矩阵！
```

---

## 4. CS2 的 dwViewMatrix 内存布局

### 4.1 内存中的存储方式

```
CS2 中 dwViewMatrix 的内存布局（16个float）：
─────────────────────────────────────────────────────────────

    dwViewMatrix = P × V  （列向量体系的组合矩阵）

    内存地址:  [base + 0x00]  [base + 0x04]  [base + 0x08]  [base + 0x0C]
    索引:          m[0]           m[1]           m[2]           m[3]
                   ↓              ↓              ↓              ↓
              ┌─────────────────────────────────────────────────────┐
              │  m[0]    m[4]    m[8]    m[12]  │  ← 第1列          │
              │  m[1]    m[5]    m[9]    m[13]  │  ← 第2列          │
              │  m[2]    m[6]    m[10]   m[14]  │  ← 第3列          │
              │  m[3]    m[7]    m[11]   m[15]  │  ← 第4列          │
              └─────────────────────────────────────────────────────┘

    注意：内存是线性存储的，但逻辑上是列主序（Column-Major）！
```

### 4.2 列主序 vs 行主序

```
列主序（Column-Major）- OpenGL/CS2 风格：
─────────────────────────────────────────────────────────────

    内存顺序：m[0], m[1], m[2], m[3], m[4], m[5], ...

    对应矩阵：
    ┌                         ┐
    │ m[0]  m[4]  m[8]   m[12] │
    │ m[1]  m[5]  m[9]   m[13] │
    │ m[2]  m[6]  m[10]  m[14] │
    │ m[3]  m[7]  m[11]  m[15] │
    └                         ┘

    第一列是 m[0-3]，第二列是 m[4-7]，以此类推


行主序（Row-Major）- DirectX 风格：
─────────────────────────────────────────────────────────────

    内存顺序：m[0], m[1], m[2], m[3], m[4], m[5], ...

    对应矩阵：
    ┌                         ┐
    │ m[0]  m[1]  m[2]   m[3]  │
    │ m[4]  m[5]  m[6]   m[7]  │
    │ m[8]  m[9]  m[10]  m[11] │
    │ m[12] m[13] m[14]  m[15] │
    └                         ┘

    第一行是 m[0-3]，第二行是 m[4-7]，以此类推
```

### 4.3 内存布局与 P × V 的对应关系

根据前面的矩阵乘法结果，P × V 的结果是：

$$M = P \times V = \begin{bmatrix}
\frac{f}{a} R_x & \frac{f}{a} R_y & \frac{f}{a} R_z & \frac{f}{a} T_x \\
f U_x & f U_y & f U_z & f T_y \\
A F_x & A F_y & A F_z & A T_z + B \\
F_x & F_y & F_z & T_z
\end{bmatrix}$$

```
内存中的对应关系：
─────────────────────────────────────────────────────────────

    m[0]  = f/a × Rx     m[1]  = f/a × Ry     m[2]  = f/a × Rz     m[3]  = f/a × Tx
    m[4]  = f × Ux       m[5]  = f × Uy       m[6]  = f × Uz       m[7]  = f × Ty
    m[8]  = A × Fx       m[9]  = A × Fy       m[10] = A × Fz       m[11] = A×Tz + B
    m[12] = Fx           m[13] = Fy           m[14] = Fz           m[15] = Tz

    其中：
    - R = Right 向量（相机右方向）
    - U = Up 向量（相机上方向）
    - F = Forward 向量（相机前方向）
    - T = Translation（相机位置相关的平移）
    - f = 1/tan(FOV/2)，a = aspect ratio
    - A, B = 深度映射参数
```

### 4.4 代码中的计算方式

```
在实际代码中，我们这样计算：
─────────────────────────────────────────────────────────────

    clip.x = world.x × m[0]  + world.y × m[1]  + world.z × m[2]  + m[3]
    clip.y = world.x × m[4]  + world.y × m[5]  + world.z × m[6]  + m[7]
    clip.z = world.x × m[8]  + world.y × m[9]  + world.z × m[10] + m[11]
    clip.w = world.x × m[12] + world.y × m[13] + world.z × m[14] + m[15]


这实际上是在计算：
─────────────────────────────────────────────────────────────

    clip.x = (f/a) × (Rx×wx + Ry×wy + Rz×wz + Tx)
           = (f/a) × (R · W + Tx)
           = 投影后的 X 坐标

    clip.y = f × (Ux×wx + Uy×wy + Uz×wz + Ty)
           = f × (U · W + Ty)
           = 投影后的 Y 坐标

    clip.w = Fx×wx + Fy×wy + Fz×wz + Tz
           = F · W + Tz
           = 相机空间中的深度（用于透视除法）

    其中 W = (wx, wy, wz) 是世界坐标
```

---

## 5. 实际应用：WorldToScreen

### 5.1 算法流程

```
WorldToScreen 的四个步骤：
─────────────────────────────────────────────────────────────

步骤1: 矩阵乘法
    clip.x = world.x × m[0]  + world.y × m[1]  + world.z × m[2]  + m[3]
    clip.y = world.x × m[4]  + world.y × m[5]  + world.z × m[6]  + m[7]
    clip.w = world.x × m[12] + world.y × m[13] + world.z × m[14] + m[15]

步骤2: 可见性检查
    如果 clip.w < 0.1，则点在相机后面，不可见

步骤3: 透视除法
    ndc.x = clip.x / clip.w
    ndc.y = clip.y / clip.w

步骤4: 视口变换
    screen.x = (ndc.x + 1) × 0.5 × 屏幕宽度
    screen.y = (1 - ndc.y) × 0.5 × 屏幕高度
```

### 5.2 内存运算的巧妙之处 ★★★

这是整个文档最精华的部分！

#### 5.2.1 代码使用的是行向量左乘

观察 `w2s` 函数的代码：

```
clip.x = world.x × m[0]  + world.y × m[1]  + world.z × m[2]  + m[3]
clip.y = world.x × m[4]  + world.y × m[5]  + world.z × m[6]  + m[7]
...
```

这种写法 `world.x * m[0] + ...` 实际上是**行向量左乘矩阵**的形式：

$$\text{Clip}^T = \text{World}^T \times M$$

其中 $M$ 是内存中按行主序存储的矩阵。

#### 5.2.2 转置法则的应用

根据矩阵转置法则：

$$(P \times V)^T = V^T \times P^T$$

如果内存中存储的是 $P \times V$ 的结果，那么当我们用行向量左乘时：

$$\text{World}^T \times (P \times V)^T = \text{World}^T \times V^T \times P^T$$

#### 5.2.3 变换顺序的物理意义

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        变换顺序分析（从左往右读）                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   World^T  ×  V^T  ×  P^T                                                   │
│      ↓         ↓       ↓                                                    │
│   世界坐标   视图变换  投影变换                                               │
│   (行向量)  (转置后)  (转置后)                                               │
│                                                                             │
│   在行向量左乘体系中，World 首先接触到的是 V^T（视图变换），                  │
│   然后才是 P^T（投影变换）。                                                 │
│                                                                             │
│   这在物理逻辑上是完全正确的变换顺序！                                       │
│   1. 先把世界坐标转换到相机空间（视图变换）                                  │
│   2. 再进行透视投影（投影变换）                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5.2.4 为什么这个设计如此巧妙

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              设计的巧妙之处                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  游戏引擎在 GPU 端使用列向量体系：                                           │
│      Clip = (P × V) × World                                                 │
│                                                                             │
│  但在内存中存储 P × V 后，CPU 端可以用行向量方式高效计算：                   │
│      Clip^T = World^T × (P × V)^T                                           │
│             = World^T × V^T × P^T                                           │
│                                                                             │
│  两种方式得到的结果是等价的（只是一个是列向量，一个是行向量）！              │
│                                                                             │
│  这样设计的好处：                                                            │
│  ✓ GPU 使用列向量体系（OpenGL/Vulkan 原生支持）                              │
│  ✓ CPU 使用行向量体系（代码更直观，缓存更友好）                              │
│  ✓ 只需存储一份矩阵，两边都能正确使用                                        │
│  ✓ 变换顺序在物理上都是正确的：先 V 后 P                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5.2.5 数学证明

$$
\begin{aligned}
\text{列向量体系：} \quad & \text{Clip} = (P \times V) \times W \\[10pt]
\text{对两边取转置：} \quad & \text{Clip}^T = [(P \times V) \times W]^T \\[10pt]
\text{应用转置法则：} \quad & \text{Clip}^T = W^T \times (P \times V)^T \\[10pt]
\text{再次应用转置法则：} \quad & \text{Clip}^T = W^T \times V^T \times P^T
\end{aligned}
$$

这就是代码实际执行的运算！

```
代码执行的本质：
─────────────────────────────────────────────────────────────

    clip.x = world.x × m[0] + world.y × m[1] + world.z × m[2] + m[3]

    这一行代码实际上在计算：

    World^T × (P×V)^T 的第一个分量
    = World^T × V^T × P^T 的第一个分量
    = 先视图变换，再投影变换后的 X 坐标

    完美！
```

---

## 6. 总结

### 6.1 核心要点

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              核心要点总结                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. CS2 内存中存储的是 P × V（投影 × 视图）的结果                            │
│                                                                             │
│  2. 代码使用行向量左乘：World^T × M                                          │
│                                                                             │
│  3. 根据转置法则：(P × V)^T = V^T × P^T                                      │
│                                                                             │
│  4. 实际执行的运算：World^T × (P × V)^T = World^T × V^T × P^T               │
│                                                                             │
│  5. 变换顺序正确：先 V（视图变换），再 P（投影变换）                          │
│                                                                             │
│  6. 这个设计的巧妙之处：                                                     │
│     - GPU 用列向量体系：(P × V) × W                                          │
│     - CPU 用行向量体系：W^T × (P × V)^T = W^T × V^T × P^T                    │
│     - 两者数学等价，只需存储一份矩阵！                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 关键公式

$$
\begin{aligned}
\text{GPU 列向量体系：} \quad & \text{Clip} = (P \times V) \times W \\[10pt]
\text{CPU 行向量体系：} \quad & \text{Clip}^T = W^T \times (P \times V)^T = W^T \times V^T \times P^T
\end{aligned}
$$

### 6.3 常见误区

```
误区1: "行向量和列向量只是写法不同"
─────────────────────────────────────────────────────────────
    错！它们决定了矩阵的存储方式和乘法顺序。
    但通过转置法则，可以在两种体系间正确转换。


误区2: "V × P 和 P × V 结果一样"
─────────────────────────────────────────────────────────────
    错！矩阵乘法不满足交换律。
    V × P ≠ P × V
    但 (P × V)^T = V^T × P^T，转置会反转顺序！


误区3: "内存里存的是 V × P"
─────────────────────────────────────────────────────────────
    错！通过 Cheat Engine 验证，内存里存的是 P × V。
    当用行向量左乘时，自动变成 W^T × V^T × P^T，
    变换顺序仍然是先 V 后 P，物理上正确！
```

---

## 参考资料

- OpenGL 矩阵约定：列向量，列主序存储
- DirectX 矩阵约定：行向量，行主序存储
- Source 2 引擎在 GPU 端使用 OpenGL 风格
- 转置法则：$(A \times B)^T = B^T \times A^T$

---

*文档最后更新: 2024*
*通过 Cheat Engine 逆向分析 CS2 得出的结论*

