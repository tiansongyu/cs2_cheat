# 墙后遮挡检测功能文档

## 📋 功能概述

墙后遮挡检测功能通过读取CS2游戏内置的视线检测系统（Spotted State），自动区分**可见敌人**和**墙后敌人**，并使用不同的视觉样式进行标识。

## 🎯 核心功能

### 1. 自动视线检测
- 利用CS2内置的 `EntitySpottedState_t` 系统
- 读取 `m_bSpotted` 字段判断敌人是否在视线内
- 无需手动射线检测，性能开销极小

### 2. 视觉区分系统

#### 方框颜色对比

| 状态 | 方框颜色 | `m_bSpotted` | 含义 |
|------|---------|--------------|------|
| **可见** | 🔴 **红色** | `true` | 敌人在直接视线内，无遮挡，可以射击 |
| **墙后** | 🟢 **绿色** | `false` | 敌人被墙壁/障碍物遮挡，需要预瞄 |

**优势：**
- 红绿对比强烈，一眼识别
- 颜色可自定义，适应不同场景
- 不影响其他ESP功能
- 性能开销极小（仅1次内存读取）

### 3. 可配置选项

| 选项 | 描述 | 默认值 |
|------|------|--------|
| **Wall Occlusion Check** | 启用/禁用墙后遮挡检测 | ✅ 开启 |
| **Box Color** | 可见敌人的方框颜色 | 🔴 红色 (255,0,0,255) |
| **Behind Wall Color** | 墙后敌人的方框颜色 | 🟢 绿色 (0,255,0,255) |

## 🔧 技术实现

### 内存偏移量

```cpp
// 在 C_CSPlayerPawnBase 中
m_entitySpottedState = 0x1F98  // EntitySpottedState_t 结构

// EntitySpottedState_t 结构内部
struct EntitySpottedState_t {
    // +0x8
    bool m_bSpotted;           // 是否被本地玩家发现（视线内）
    
    // +0xC
    uint32_t m_bSpottedByMask[2];  // 被哪些玩家发现的位掩码
};
```

### 读取逻辑

```cpp
// 读取敌人的 spotted 状态
uintptr_t entitySpottedState = entity + 
    cs2_dumper::schemas::client_dll::C_CSPlayerPawnBase::m_entitySpottedState;

// m_bSpotted 在 EntitySpottedState_t 的偏移 0x8
bool isSpotted = memory::Read<bool>(entitySpottedState + 0x8);

// isSpotted = true  -> 敌人可见（无遮挡）
// isSpotted = false -> 敌人被墙遮挡
```

### 渲染逻辑

```cpp
// 根据可见性选择颜色
uint8_t r, g, b, a;

if (menu::espWallCheck && !enemy.isSpotted) {
    // 墙后敌人 - 绿色方框
    r = 0; g = 255; b = 0; a = 255;
} else {
    // 可见敌人 - 红色方框
    r = 255; g = 0; b = 0; a = 255;
}

// 绘制实线方框（颜色区分可见性）
sdl_renderer::draw::box(x, y, w, h, r, g, b, a);
```

## 🎮 使用方法

### 菜单设置

1. 按 **F4** 打开菜单
2. 在 "ESP Settings" 中找到：
   - ✅ **Box ESP** - 启用方框ESP
   - ✅ **Wall Occlusion Check** - 启用墙后检测
   - 🎨 **Box Color** - 可见敌人颜色（红色）
   - 🎨 **Behind Wall Color** - 墙后敌人颜色（黄色）

### 实战应用

#### 场景1：清点/搜索
1. 看到**虚线黄色方框** - 敌人在墙后
2. 预瞄墙角/门口
3. 等待敌人露头
4. 方框变为**实线红色** - 敌人露头，立即开火！

#### 场景2：穿墙判断
1. 看到**虚线方框** - 敌人在墙后
2. 判断墙体材质（木板/薄墙可穿透）
3. 预判位置进行穿墙射击

#### 场景3：战术撤退
1. 多个**实线红色方框** - 多个敌人可见
2. 敌人数量过多，考虑撤退
3. 撤退时观察**虚线方框** - 判断是否有敌人绕后

#### 场景4：信息收集
1. **虚线方框**数量 = 墙后敌人数量
2. **实线方框**数量 = 可见敌人数量
3. 快速评估战场态势

## 🎨 视觉效果示例

```
可见敌人（直接视线）:
      ●●●●●      (红色眼睛)
    ┏━━━━━━━┓    (🔴 红色方框)
    ┃       ┃
    ┃ AK-47 ┃
    ┗━━━━━━━┛

墙后敌人（被遮挡）:
      ●●●●●      (红色眼睛)
    ┏━━━━━━━┓    (🟢 绿色方框)
    ┃       ┃
    ┃ AK-47 ┃
    ┗━━━━━━━┛
```

## ⚙️ 配置建议

### 推荐设置

```cpp
espWallCheck = true;  // 必须开启
espBoxColor = {1.0, 0.0, 0.0, 1.0};      // 红色 - 可见敌人
espWallColor = {0.0, 1.0, 0.0, 1.0};     // 绿色 - 墙后敌人
```

### 颜色方案

#### 可见敌人颜色（默认红色）
| 方案 | 颜色 | RGB | 说明 |
|------|------|-----|------|
| **经典红色** | 🔴 | (255,0,0) | 推荐，警戒色，表示危险 |
| **白色** | ⚪ | (255,255,255) | 简洁明了 |
| **黄色** | 🟡 | (255,255,0) | 高亮显示 |

#### 墙后敌人颜色（默认绿色）
| 方案 | 颜色 | RGB | 说明 |
|------|------|-----|------|
| **亮绿色** | 🟢 | (0,255,0) | 推荐，表示"安全"（暂时无法射击） |
| **蓝色** | 🔵 | (0,150,255) | 冷色调，区分度高 |
| **橙色** | 🟠 | (255,165,0) | 警告色 |
| **灰色** | ⚫ | (150,150,150) | 低调不刺眼 |

## 💡 战术建议

### 进攻时
1. **优先击杀可见敌人**（实线方框）
2. **记住墙后敌人位置**（虚线方框）
3. **预瞄墙角** - 等待虚线变实线

### 防守时
1. **观察虚线方框移动** - 判断敌人推进路线
2. **提前准备闪光弹/烟雾弹**
3. **架枪等待** - 敌人露头瞬间击杀

### 团队配合
1. **报点** - "A点有3个，2个墙后1个可见"
2. **协同进攻** - 队友投闪，你观察虚线变实线
3. **交叉火力** - 一人吸引可见敌人，另一人击杀墙后敌人

## 🐛 常见问题

### Q: 为什么远距离敌人明明在视野内，却显示绿色？
A: **这是 `m_bSpotted` 的距离限制问题！**

**原因**:
- CS2游戏引擎为了性能优化，限制了 `m_bSpotted` 的有效距离
- 超过约 **2000 游戏单位**（~50米）后，`m_bSpotted` 会失效
- 即使敌人在视野内，`m_bSpotted` 仍然返回 `false`

**解决方案**:
我们实现了**混合检测系统**：
- **近距离**（< 2000单位）: 使用 `m_bSpotted`（精确）
- **远距离**（≥ 2000单位）: 假设敌人可见（显示红色）

**如何调整**:
1. 打开菜单（F4）
2. 找到 "Wall Occlusion Check"
3. 调整 "Max Detection Distance" 滑块
   - 增加阈值 → 更多敌人使用精确检测
   - 减少阈值 → 更多敌人假设可见

**推荐设置**: 2000 单位（默认）

详细说明: [SPOTTED_DISTANCE_LIMITATION.md](SPOTTED_DISTANCE_LIMITATION.md)

### Q: 为什么有时候敌人明明可见，却显示绿色？（近距离）
A: 可能原因：
- 敌人刚露头，游戏spotted状态更新有延迟（约0.1秒）
- 敌人只露出很小一部分（如手臂）
- 烟雾弹/闪光弹影响视线判定

### Q: 绿色方框看不清怎么办？
A: 调整墙后敌人颜色：
- 使用更亮的颜色（如白色、青色、黄色）
- 在菜单中自定义 "Behind Wall Color"

### Q: 如何关闭墙后检测？
A: 在菜单中取消勾选 "Wall Occlusion Check"

## 📝 数据结构

### EnemyInfo 结构
```cpp
struct EnemyInfo {
    vec3 position;
    vec3 headPosition;
    int32_t health;
    float distance;
    std::string weaponName;
    float viewYaw;
    float angleToPlayer;
    float flashDuration;
    bool isFlashed;
    bool isSpotted;  // 新增：是否被发现（可见）
};
```

## 🔬 技术细节

### Spotted State 更新机制

CS2的spotted state由游戏引擎自动更新：
- **更新频率**：约每帧（60-144Hz）
- **判定条件**：
  - 敌人在视野范围内（FOV）
  - 敌人与玩家之间无实体遮挡
  - 敌人未被烟雾/闪光完全遮挡

### 性能优势

相比手动射线检测：
- **无额外计算** - 直接读取游戏数据
- **准确性高** - 使用游戏引擎的判定结果
- **性能开销小** - 仅一次内存读取

## 🎯 总结

墙后遮挡检测功能通过简单的视觉区分（实线/虚线），让你在游戏中快速判断敌人位置和可见性，大幅提升战术意识和反应速度。

**核心优势：**
- ✅ 自动检测，无需手动判断
- ✅ 视觉清晰，一眼识别
- ✅ 性能优秀，无卡顿
- ✅ 高度可定制，适应各种场景

