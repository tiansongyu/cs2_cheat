# CS2 投影矩阵原理详解

## 目录
1. [核心概念：dwViewMatrix 的本质](#1-核心概念dwviewmatrix-的本质)
2. [先验知识](#2-先验知识)
3. [View Matrix（视图矩阵）详解](#3-view-matrix视图矩阵详解)
4. [Projection Matrix（投影矩阵）详解](#4-projection-matrix投影矩阵详解)
5. [两个矩阵的组合](#5-两个矩阵的组合)
6. [WorldToScreen 实战应用](#6-worldtoscreen-实战应用)
7. [附录：基础知识](#7-附录基础知识)
8. [总结](#8-总结)

---

## 1. 核心概念：dwViewMatrix 的本质

### 1.1 CS2 中的 ViewMatrix 是什么？

在 CS2 中，`dwViewMatrix` 是一个 **4×4 矩阵（16个float）**，它能将 **世界坐标** 直接转换为 **裁剪空间坐标**。

**🔥 核心理解：CS2 的 dwViewMatrix = View Matrix × Projection Matrix**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   dwViewMatrix = View Matrix（视图矩阵）× Projection Matrix（投影矩阵）       │
│                                                                             │
│   两个矩阵预先相乘，一次矩阵运算就能完成 世界坐标 → 屏幕坐标 的转换！          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 为什么是两个矩阵的组合？

```
单独使用两个矩阵的流程：

   世界坐标                相机坐标                裁剪坐标
      ●      ──────────>      ●      ──────────>     ●
   (x,y,z)    × View       (相对相机)   × Proj     (clip.x,y,z,w)


CS2 的优化：预先合并两个矩阵

   世界坐标                              裁剪坐标
      ●      ────────────────────────>     ●
   (x,y,z)    × dwViewMatrix            (clip.x,y,z,w)
              (View × Proj)

   ★ 更高效！只需一次矩阵乘法
```

### 1.3 两个矩阵各自的职责

| 矩阵 | 英文名 | 作用 | 输入 → 输出 |
|------|--------|------|-------------|
| **视图矩阵** | View Matrix | 将世界坐标转换为相机视角的坐标 | 世界空间 → 相机空间 |
| **投影矩阵** | Projection Matrix | 实现透视效果（近大远小） | 相机空间 → 裁剪空间 |

---

## 2. 先验知识

### 2.1 齐次坐标

在 3D 图形学中，我们使用 **4D 向量** 表示 3D 点：

```
      ┌   ┐
      │ x │
  P = │ y │    其中 w = 1 表示点，w = 0 表示方向向量
      │ z │
      │ w │
      └   ┘
```

**为什么需要齐次坐标？**
- 可以用矩阵乘法统一表示平移、旋转、缩放
- 透视投影需要用到 w 分量进行**透视除法**（这是实现"近大远小"的关键！）

### 2.2 矩阵与向量相乘

4×4 矩阵乘以 4×1 向量：

```
┌                       ┐   ┌   ┐     ┌                                    ┐
│ m[0]   m[1]   m[2]   m[3]  │   │ x │     │ x×m[0] + y×m[1] + z×m[2] + w×m[3]  │
│ m[4]   m[5]   m[6]   m[7]  │ × │ y │  =  │ x×m[4] + y×m[5] + z×m[6] + w×m[7]  │
│ m[8]   m[9]   m[10]  m[11] │   │ z │     │ x×m[8] + y×m[9] + z×m[10]+ w×m[11] │
│ m[12]  m[13]  m[14]  m[15] │   │ w │     │ x×m[12]+ y×m[13]+ z×m[14]+ w×m[15] │
└                       ┘   └   ┘     └                                    ┘
```

### 2.3 坐标系统

CS2 使用**左手坐标系**：
- **X 轴**：向右
- **Y 轴**：向上
- **Z 轴**：向前（深度方向）

---

## 3. View Matrix（视图矩阵）详解

### 3.1 View Matrix 的作用

View Matrix（视图矩阵）的作用是：**将世界坐标转换为相机坐标**。

```
想象你是相机：

    世界空间                          相机空间（你的视角）
         Y ↑                              Y ↑
           │   ● 敌人                       │
           │                               │  ● 敌人（在你右前方）
    相机 ● │                               ●───→ X
           ●───→ X                        /  你在原点
          /                              Z
         Z

View Matrix 做的事情：
1. 把整个世界"移动"，让相机变成原点
2. 把整个世界"旋转"，让相机的朝向变成Z轴正方向
```

### 3.2 View Matrix 的数学结构

View Matrix 由两部分组成：**旋转矩阵 R** 和 **平移向量 T**

```
View Matrix = Rotation × Translation

完整的 4×4 View Matrix：

┌                                      ┐
│ Rx      Ry      Rz      0            │  ← Right 向量（相机的"右"方向）
│ Ux      Uy      Uz      0            │  ← Up 向量（相机的"上"方向）
│ Fx      Fy      Fz      0            │  ← Forward 向量（相机的"前"方向）
│ Tx      Ty      Tz      1            │  ← 平移（相机位置的负点积）
└                                      ┘
```

### 3.3 View Matrix 每个元素的含义

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    View Matrix 结构解析（4×4 矩阵）                          │
└─────────────────────────────────────────────────────────────────────────────┘

索引:   [0]     [1]     [2]     [3]
       ┌───────────────────────────────┐
行0    │  Rx      Ry      Rz      0    │  Right 向量 (相机X轴在世界中的方向)
       ├───────────────────────────────┤
行1    │  Ux      Uy      Uz      0    │  Up 向量 (相机Y轴在世界中的方向)
       ├───────────────────────────────┤
行2    │  Fx      Fy      Fz      0    │  Forward 向量 (相机Z轴在世界中的方向)
       ├───────────────────────────────┤
行3    │ -E·R    -E·U    -E·F     1    │  平移分量 (相机位置E与各轴的负点积)
       └───────────────────────────────┘

其中：
- R = (Rx, Ry, Rz) = 相机的右向量 (Right)
- U = (Ux, Uy, Uz) = 相机的上向量 (Up)
- F = (Fx, Fy, Fz) = 相机的前向向量 (Forward)
- E = (Ex, Ey, Ez) = 相机在世界中的位置 (Eye)
- E·R = Ex×Rx + Ey×Ry + Ez×Rz （点积）
```

### 3.4 为什么平移部分是负的点积？

```
假设相机在世界坐标 (100, 0, 0)，面向原点：

    世界空间：

         相机
            ●───────────────────● 原点
              100米

    转换到相机空间后：

         原点在相机的"左边"100米

            ● ←────────────────● 相机（现在是原点）
         -100米

所以平移部分需要取负值：
    Tx = -E·R = -(相机位置 · 右向量)

这样世界中的原点，在相机空间中的X坐标就变成了 -100
```

### 3.5 构建相机坐标系的三个向量

```
步骤1: 计算 Forward 向量（相机看向的方向）
───────────────────────────────────────────
    Forward = Normalize(Target - Eye)

              Target ●
                    ╱
                   ╱ Forward
                  ╱
           Eye  ●


步骤2: 计算 Right 向量（相机的右边）
───────────────────────────────────────────
    Right = Normalize(Cross(WorldUp, Forward))

    使用叉积：WorldUp × Forward = Right

              WorldUp
               ↑
               │
               ●───────→ Right
              ╱
             ╱ Forward


步骤3: 计算真正的 Up 向量
───────────────────────────────────────────
    Up = Cross(Forward, Right)

    确保三个向量完全正交（互相垂直90°）
```

---

## 4. Projection Matrix（投影矩阵）详解

### 4.1 Projection Matrix 的作用

Projection Matrix（投影矩阵）的作用是：**实现透视效果（近大远小）**。

```
日常生活中的透视现象：
- 远处的物体看起来更小
- 平行的铁轨在远处汇聚成一点

    近处                     远处
    ┌───┐                    ┌─┐
    │   │   ──────────────>  │ │
    │   │                    └─┘
    └───┘                    更小！
```

### 4.2 透视投影的数学原理

透视投影的核心是**相似三角形**：

```
侧视图：

         屏幕                    3D点
           │                      ●
           │                    ╱
           │                  ╱
           │ y'             ╱ y
           ├──────        ╱
           │      ╲     ╱
      眼睛 ●────────────────────────────
                d        z

    根据相似三角形:

        y'     y              y × d
       ─── = ───    ==>  y' = ─────
        d     z                 z

核心公式：
    screen_x = x × f / z
    screen_y = y × f / z

    其中 f 与视场角 FOV 相关
```

### 4.3 Projection Matrix 的数学结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Projection Matrix 结构（4×4 矩阵）                        │
└─────────────────────────────────────────────────────────────────────────────┘

索引:   [0]       [1]       [2]       [3]
       ┌───────────────────────────────────────┐
行0    │ f/aspect   0         0         0      │  X 缩放（考虑宽高比）
       ├───────────────────────────────────────┤
行1    │    0       f         0         0      │  Y 缩放
       ├───────────────────────────────────────┤
行2    │    0       0      zf/(zf-zn)   1      │  Z 映射 + 透视标记
       ├───────────────────────────────────────┤
行3    │    0       0    -zf×zn/(zf-zn) 0      │  Z 偏移
       └───────────────────────────────────────┘

参数说明：
- f = 1 / tan(FOV/2)   视场角因子
- aspect = width/height 屏幕宽高比
- zn = near plane      近裁剪面距离
- zf = far plane       远裁剪面距离
```

### 4.4 每个元素的含义

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ 元素 [0,0] = f / aspect                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：X 方向的缩放因子                                                       │
│ - f 越大（FOV越小）→ 物体在屏幕上越大（长焦效果）                              │
│ - aspect 修正宽高比，避免物体变形                                            │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 元素 [1,1] = f                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：Y 方向的缩放因子                                                       │
│ - 与 FOV 直接相关                                                            │
│ - f = 1/tan(FOV/2)                                                          │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 元素 [2,2] = zf / (zf - zn)                                                 │
│ 元素 [3,2] = -zf × zn / (zf - zn)                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：将 Z 坐标映射到 [0, 1] 范围（用于深度测试）                              │
│ - zn (near plane): 太近的物体被裁掉                                          │
│ - zf (far plane): 太远的物体被裁掉                                           │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 元素 [2,3] = 1        ★★★ 最关键的元素！★★★                               │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：将原始 Z 坐标存入 w 分量                                                │
│                                                                             │
│ 变换后：w_new = z_old × 1 = z_old                                           │
│                                                                             │
│ 这样在"透视除法"时，除以 w 就等于除以 z：                                     │
│   x_screen = x_clip / w = x_clip / z  → 远处物体 x 变小                      │
│   y_screen = y_clip / w = y_clip / z  → 远处物体 y 变小                      │
│                                                                             │
│ 这就是"近大远小"透视效果的数学本质！                                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.5 FOV（视场角）的影响

```
FOV 与 f 的关系：

         ╱│╲
        ╱ │ ╲
       ╱  │  ╲
      ╱   │   ╲
     ╱    │    ╲
    ╱ FOV │     ╲
   ╱──────┼──────╲
  ●───────┴───────
 眼睛    d=1

f = 1 / tan(FOV/2)

FOV = 90°  → f = 1.0    （标准视角）
FOV = 60°  → f = 1.73   （更窄，物体更大，长焦效果）
FOV = 120° → f = 0.58   （更宽，物体更小，广角效果）

CS2 默认 FOV ≈ 90°
狙击镜开镜 FOV ≈ 30-40°（所以敌人看起来更大）
```

---

## 5. 两个矩阵的组合

### 5.1 dwViewMatrix = View × Projection

CS2 的 `dwViewMatrix` 是 View Matrix 和 Projection Matrix 相乘的结果：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   dwViewMatrix[16] = View Matrix[16] × Projection Matrix[16]                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

View Matrix (4×4)         Projection Matrix (4×4)      dwViewMatrix (4×4)
┌─────────────────┐       ┌─────────────────┐          ┌─────────────────┐
│ Rx   Ry   Rz  0 │       │ f/a  0    0   0 │          │                 │
│ Ux   Uy   Uz  0 │   ×   │  0   f    0   0 │    =     │  组合后的矩阵    │
│ Fx   Fy   Fz  0 │       │  0   0   A   1  │          │  (16个float)    │
│ Tx   Ty   Tz  1 │       │  0   0   B   0  │          │                 │
└─────────────────┘       └─────────────────┘          └─────────────────┘
```

### 5.2 组合矩阵的内存布局

```
dwViewMatrix 在内存中的布局（16个float，行主序）：

索引:  [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]   [8]   [9]  [10]  [11]  [12]  [13]  [14]  [15]
       └─────────────────┘   └─────────────────┘   └─────────────────┘   └─────────────────┘
            第0行                  第1行                  第2行                  第3行
         计算 clip.x            计算 clip.y            计算 clip.z            计算 clip.w
```

### 5.3 组合矩阵每行的含义

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ 行0: vm[0], vm[1], vm[2], vm[3]                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：计算裁剪空间的 X 坐标 (clip.x)                                          │
│                                                                             │
│ clip.x = worldX × vm[0] + worldY × vm[1] + worldZ × vm[2] + vm[3]           │
│                                                                             │
│ 包含了：                                                                     │
│ - 相机右向量 (Right) 的影响                                                  │
│ - X方向的透视缩放 (f/aspect)                                                 │
│ - 相机位置的X偏移                                                            │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 行1: vm[4], vm[5], vm[6], vm[7]                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：计算裁剪空间的 Y 坐标 (clip.y)                                          │
│                                                                             │
│ clip.y = worldX × vm[4] + worldY × vm[5] + worldZ × vm[6] + vm[7]           │
│                                                                             │
│ 包含了：                                                                     │
│ - 相机上向量 (Up) 的影响                                                     │
│ - Y方向的透视缩放 (f)                                                        │
│ - 相机位置的Y偏移                                                            │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 行2: vm[8], vm[9], vm[10], vm[11]                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：计算裁剪空间的 Z 坐标 (clip.z)                                          │
│                                                                             │
│ clip.z = worldX × vm[8] + worldY × vm[9] + worldZ × vm[10] + vm[11]         │
│                                                                             │
│ 用于深度测试，判断物体的前后遮挡关系                                          │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 行3: vm[12], vm[13], vm[14], vm[15]       ★★★ 最重要的一行 ★★★            │
├─────────────────────────────────────────────────────────────────────────────┤
│ 作用：计算 clip.w（透视除法的分母）                                           │
│                                                                             │
│ clip.w = worldX × vm[12] + worldY × vm[13] + worldZ × vm[14] + vm[15]       │
│                                                                             │
│ ★ clip.w 本质上代表了点到相机的"深度"                                        │
│ ★ 透视除法时：screen = clip / clip.w                                         │
│ ★ 这就是"近大远小"效果的来源！                                               │
│                                                                             │
│ clip.w > 0：点在相机前方（可见）                                              │
│ clip.w < 0：点在相机后方（不可见，不应渲染）                                  │
│ clip.w ≈ 0：点在相机平面上（会导致除零错误）                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.4 为什么要组合两个矩阵？

```
性能优化：

方式1：分离矩阵（需要两次矩阵乘法）
─────────────────────────────────────
viewPos = worldPos × ViewMatrix      // 第一次乘法 (16次乘法+12次加法)
clipPos = viewPos × ProjMatrix       // 第二次乘法 (16次乘法+12次加法)
总计: 32次乘法 + 24次加法


方式2：组合矩阵（只需一次矩阵乘法）  ← CS2 使用这种方式
─────────────────────────────────────
clipPos = worldPos × dwViewMatrix    // 一次乘法 (16次乘法+12次加法)
总计: 16次乘法 + 12次加法

★ 效率提升一倍！
```

---

## 6. WorldToScreen 实战应用

### 6.1 完整算法流程

```
输入: 世界坐标 worldPos = (x, y, z)
      视图矩阵 viewMatrix[16]（从游戏内存读取）
      屏幕尺寸 (width, height)
输出: 屏幕坐标 screenPos = (sx, sy)

┌─────────────────────────────────────────────────────────────────┐
│  步骤1: 矩阵乘法                                                 │
│  世界坐标 × ViewMatrix = 裁剪坐标 (clip.x, clip.y, clip.z, clip.w)│
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步骤2: 可见性检查                                               │
│  if (clip.w < 0.001) return false; // 在相机后面                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步骤3: 透视除法                                                 │
│  ndc.x = clip.x / clip.w                                        │
│  ndc.y = clip.y / clip.w                                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步骤4: 视口变换                                                 │
│  screen.x = (ndc.x + 1) × 0.5 × width                           │
│  screen.y = (1 - ndc.y) × 0.5 × height  // Y轴翻转               │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 步骤1详解：矩阵乘法

矩阵乘法的本质是：**世界坐标与矩阵每一行做点积**

```
clip.x = worldX × vm[0]  + worldY × vm[1]  + worldZ × vm[2]  + vm[3]   ← 行0
clip.y = worldX × vm[4]  + worldY × vm[5]  + worldZ × vm[6]  + vm[7]   ← 行1
clip.z = worldX × vm[8]  + worldY × vm[9]  + worldZ × vm[10] + vm[11]  ← 行2
clip.w = worldX × vm[12] + worldY × vm[13] + worldZ × vm[14] + vm[15]  ← 行3
```

### 6.3 步骤2详解：可见性检查

**为什么检查 clip.w？**
```
clipW 本质上代表点到相机的"深度":

clipW > 0: 点在相机前方 ✓ 可见
clipW < 0: 点在相机后方 ✗ 不可见
clipW ≈ 0: 点在相机平面上 ✗ 会导致除零错误
```

### 6.4 步骤3详解：透视除法

透视除法的公式：
```
ndc.x = clip.x / clip.w    范围约 [-1, 1]
ndc.y = clip.y / clip.w    范围约 [-1, 1]
```

**这就是透视效果的数学本质！**
- 远处物体的 clip.w（深度）大
- 除以 clip.w 后，ndc.x 和 ndc.y 变小
- 在屏幕上显示更小 → 近大远小

### 6.5 步骤4详解：视口变换

视口变换的公式：
```
screen.x = (ndc.x + 1) × 0.5 × 屏幕宽度
screen.y = (1 - ndc.y) × 0.5 × 屏幕高度    ← Y轴翻转！
```

**为什么 Y 轴要翻转？**
```
NDC坐标系：              屏幕坐标系：
    Y ↑                  (0,0)┌────────────→ X
      │                       │
      │                       │
      ●───→ X                 ↓ Y

NDC 中 Y 向上为正         屏幕中 Y 向下为正
所以需要翻转：screenY = (1 - ndcY) × ...
```

### 6.6 图解完整流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        World to Screen 完整流程                              │
└─────────────────────────────────────────────────────────────────────────────┘

    世界空间                                              屏幕空间

         Y ↑                                         (0,0)┌──────────────┐
           │    ● 敌人位置                                │              │
           │   (100, 50, 200)                             │    ● (960,   │
           │                                              │      400)    │
           ●───────→ X                                    │              │
          /                                               └──────────────┘
         Z                                                         (1920,1080)

                              │
                              │  × ViewMatrix (矩阵乘法)
                              ▼

    裁剪空间 (Clip Space)

    clipX = 100×vm[0] + 50×vm[1] + 200×vm[2] + vm[3]
    clipY = 100×vm[4] + 50×vm[5] + 200×vm[6] + vm[7]
    clipW = 100×vm[12]+ 50×vm[13]+ 200×vm[14]+ vm[15]

                              │
                              │  ÷ clipW (透视除法)
                              ▼

    NDC空间 (Normalized Device Coordinates)

    ndcX = clipX / clipW
    ndcY = clipY / clipW
    范围: [-1, 1]

                              │
                              │  视口变换
                              ▼

    屏幕空间 (Screen Space)

    screenX = (ndcX + 1) × 0.5 × 1920
    screenY = (1 - ndcY) × 0.5 × 1080

    最终像素坐标！
```

---

## 7. 附录：基础知识

### 7.1 向量运算

**向量点积（内积）：**
```
A · B = Ax×Bx + Ay×By + Az×Bz

用途：计算两个向量的夹角、投影
结果：标量（一个数）
```

**向量叉积（外积）：**
```
A × B = (Ay×Bz - Az×By, Az×Bx - Ax×Bz, Ax×By - Ay×Bx)

用途：计算垂直于两个向量的法向量
结果：向量
```

### 7.2 变换流水线总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          3D 投影变换流水线                                    │
└─────────────────────────────────────────────────────────────────────────────┘

    模型空间 (Local)                原始顶点定义
         │
         ▼ × Model Matrix (旋转+缩放+平移)
         │
    世界空间 (World)                物体在世界中的位置
         │
         ▼ × View Matrix (相机变换)
         │
    相机空间 (View)                 以相机为原点
         │
         ▼ × Projection Matrix (透视投影)
         │
    裁剪空间 (Clip)                 齐次坐标 (x, y, z, w)
         │
         ▼ ÷ w (透视除法)           ★ 透视效果的核心！
         │
    NDC空间                         归一化坐标 [-1, 1]
         │
         ▼ × 屏幕尺寸 (视口变换)
         │
    屏幕空间 (Screen)               像素坐标 (px, py)
```

### 7.3 核心公式总结

**透视投影的本质**：
```
screen_x = clip_x / clip_w = x × f / z
screen_y = clip_y / clip_w = y × f / z

其中 f = 1 / tan(FOV/2)
```

**为什么远处物体变小**：
- 远处物体 z 值大（clip_w 大）
- 除以 z 后，x 和 y 的绝对值变小
- 在屏幕上显示更小

---

## 8. 总结

### 8.1 CS2 dwViewMatrix 的本质

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   dwViewMatrix = View Matrix × Projection Matrix                            │
│                                                                             │
│   ┌─────────────────┐                                                       │
│   │   View Matrix   │ → 将世界坐标转换为相机视角坐标                         │
│   │   (视图矩阵)     │   包含：相机位置、相机朝向（Right/Up/Forward向量）    │
│   └─────────────────┘                                                       │
│            ×                                                                │
│   ┌─────────────────┐                                                       │
│   │ Projection Mat  │ → 实现透视效果（近大远小）                             │
│   │   (投影矩阵)     │   包含：FOV、宽高比、近/远裁剪面                       │
│   └─────────────────┘                                                       │
│            =                                                                │
│   ┌─────────────────┐                                                       │
│   │  dwViewMatrix   │ → 一次矩阵乘法完成 世界坐标→屏幕坐标                    │
│   │   (组合矩阵)     │   16个float，每4个一行                                 │
│   └─────────────────┘                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 矩阵每行的作用

| 行号 | 索引 | 作用 | 计算 |
|------|------|------|------|
| 行0 | vm[0-3] | 计算 clip.x（水平位置） | x×vm[0] + y×vm[1] + z×vm[2] + vm[3] |
| 行1 | vm[4-7] | 计算 clip.y（垂直位置） | x×vm[4] + y×vm[5] + z×vm[6] + vm[7] |
| 行2 | vm[8-11] | 计算 clip.z（深度） | x×vm[8] + y×vm[9] + z×vm[10] + vm[11] |
| 行3 | vm[12-15] | 计算 clip.w（透视除法分母）★ | x×vm[12] + y×vm[13] + z×vm[14] + vm[15] |

### 8.3 WorldToScreen 核心步骤

```
WorldToScreen 算法的四个核心步骤：

步骤1: 矩阵乘法
─────────────────────────────────────────────────────────────
clip.x = world.x × vm[0]  + world.y × vm[1]  + world.z × vm[2]  + vm[3]
clip.y = world.x × vm[4]  + world.y × vm[5]  + world.z × vm[6]  + vm[7]
clip.w = world.x × vm[12] + world.y × vm[13] + world.z × vm[14] + vm[15]


步骤2: 可见性检查
─────────────────────────────────────────────────────────────
如果 clip.w < 0.001，则点在相机后面，不可见


步骤3: 透视除法
─────────────────────────────────────────────────────────────
ndc.x = clip.x / clip.w
ndc.y = clip.y / clip.w


步骤4: 视口变换
─────────────────────────────────────────────────────────────
screen.x = (ndc.x + 1) × 0.5 × 屏幕宽度
screen.y = (1 - ndc.y) × 0.5 × 屏幕高度
```

---

## 参考资源

- [learnopengl.com - Transformations](https://learnopengl.com/Getting-started/Transformations)
- [songho.ca - OpenGL Projection Matrix](http://www.songho.ca/opengl/gl_projectionmatrix.html)
- Source Engine SDK Documentation

---

*文档最后更新: 2024*